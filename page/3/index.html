<!doctype html>
<html lang="zh-cn">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.56.3" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>西红柿的博客 | Awesome TomatoAres</title>
    <meta property="og:title" content="西红柿的博客 | Awesome TomatoAres">
    <meta property="og:type" content="website">
    <meta name="Keywords" content="Gopher,博客,Web,Pythoner">
    <meta name="description" content="A nook preserved in Cyberspace where I can be myself.">
    <meta property="og:url" content="https://TomatoAres.github.io/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <link rel="alternate" type="application/rss+xml+xml" href="https://TomatoAres.github.io/index.xml" title="西红柿的博客" />
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    


    
    
</head>


<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <h1>
                        <a id="logo" href="https://TomatoAres.github.io/">
                            西红柿的博客
                        </a>
                    </h1>
                
                <p class="description">Awesome TomatoAres</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://TomatoAres.github.io/">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://TomatoAres.github.io/posts/hugo-%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/" title="Hugo 静态文件使用" >Hugo 静态文件使用</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年8月29日
                            </date>
                            
                            <div class="post-content">
                                放入 static 文件夹下
例如： 图片放入 image 下 network 文件下
！[说明文字](/image/network/文件名)  ……
                            </div>
                            <p class="readmore"><a href="https://TomatoAres.github.io/posts/hugo-%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://TomatoAres.github.io/posts/hugo-%E6%A0%B7%E5%BC%8F/" title="Hugo github.io 无样式问题" >Hugo github.io 无样式问题</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年8月29日
                            </date>
                            
                            <div class="post-content">
                                hugo 建站后，生成静态页面并上传 github 仓库，无法正常显示主题样式
hugo --theme=ananke --baseUrl=&quot;http://TomatoAres.github.io/&quot;  将上述命令中的 http 改为 https 即可解决
hugo --theme=ananke --baseUrl=&quot;https://TomatoAres.github.io/&quot;  参考：使用 Hugo 搭建个人博客……
                            </div>
                            <p class="readmore"><a href="https://TomatoAres.github.io/posts/hugo-%E6%A0%B7%E5%BC%8F/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://TomatoAres.github.io/posts/go-test/" title="go test 工具的简单介绍和使用" >go test 工具的简单介绍和使用</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年8月29日
                            </date>
                            
                            <div class="post-content">
                                简单介绍 go test 子命令是 Go 语言包的测试驱动程序，在一个包目录中，以*_test.go命名方式的文件，是go test编译的目标（不是go build）
在*_test.go 文件中，三种函数需要特殊对待，即功能测试函数、基准测试函数和示例函数：
 功能测试函数：以Test前缀命名的函数，用来检测一些程序逻辑的正确性 基准测试函数：以Benchmark开头，用来测试某些操作的性能 示例函数：以Example开头，用来提供机器检查过的文档 参考代码1 参考代码2  简单使用 Test函数 首先，在某一工程目录下创建两个文件：test.go(即源码文件)和test_test.go(即单元测试文件)，因为go test 命令只能在一个相应的目录下执行所有文件
test.go源码文件，创建一个test包，并实现一个除法运算 package test import ( &quot;errors&quot; ) func Division(a, b float64) (float64, error) { if b == 0 { return 0, errors.New(&quot;除数不能为0&quot;) } return a / b, nil }  test_test.go 测试单元文件  注意事项：
 文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码 你必须import testing这个包 测试用例会按照源代码中写的顺序依次执行 测试格式：func TestXxx (t *testing.T),Xxx部分可以为任意的字母数字的组合，但是首字母一定为大写字母 函数中通过调用testing.T的一些方法来说明测试通过或不通过： 调用t.Error()或t.Errorf()方法记录日志并标记测试失败,测试函数中的某条测试用例执行结果与预期不符时使用 Log和Logf方法用于日志输出，默认只输出错误日志，如果要输出全部日志需要使用-v Fail标记用例失败，但继续执行当前用例。FailNow标记用例失败并且立即停止执行当前用例，继续执行下一个（默认按书写顺序）用例 Error等价于Log加Fail，Errorf等价于Logf加Fail 使用t.……
                            </div>
                            <p class="readmore"><a href="https://TomatoAres.github.io/posts/go-test/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://TomatoAres.github.io/posts/benchmark/" title="性能测试中 allocs/op 和 B/op 的含义" >性能测试中 allocs/op 和 B/op 的含义</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年8月29日
                            </date>
                            
                            <div class="post-content">
                                 allocs/op 表示每个 op 发生多少个不同的内存分配（单次迭代）。越小越好 B/op 是每个操作分配了多少字节。 越小越好  ……
                            </div>
                            <p class="readmore"><a href="https://TomatoAres.github.io/posts/benchmark/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://TomatoAres.github.io/posts/tcp-%E6%80%BB%E7%BB%93/" title="TCP 总结" >TCP 总结</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年8月29日
                            </date>
                            
                            <div class="post-content">
                                通信过程 服务端：
 socket：建立 socket bind：绑定服务端 ip listen：开始监听 accept：等待连接（阻塞） read/write：通信 close：关闭连接  三次握手——建立通信过程 参考：TCP 的三次握手与四次挥手（详解+动图）
涉及到状态：
 closed SYN_SENT SYN_RECV ESTABLISHED  四次挥手——断开连接 涉及到状态：
 ESTABLISHED FIN_WAIT1 FIN_WAIT2  问题总结  tcp 的 2MSL 问题
MSL：Maximum Segment Lifetime，最长报文时间
2MSL 即两倍的 MSL ，TCP 的 TIME_WAIT 状态也称为 2MSL 等待状态，
当 TCP 的一端发起主动关闭，在发出最后一个 ACK 包后，
即第 3 次握手完成后发送了第四次握手的 ACK 包后就进入了 TIME_WAIT 状态，
必须在此状态上停留两倍的 MSL 时间，
等待 2MSL 时间主要目的是怕最后一个 ACK 包对方没收到，
那么对方在超时后将重发第三次握手的 FIN 包，……
                            </div>
                            <p class="readmore"><a href="https://TomatoAres.github.io/posts/tcp-%E6%80%BB%E7%BB%93/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://TomatoAres.github.io/posts/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/" title="进程线程协程总结" >进程线程协程总结</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年8月22日
                            </date>
                            
                            <div class="post-content">
                                通俗易懂的例子 参考:每个程序员都会遇到的面试问题：谈谈进程和线程的区别
1.计算机的核心是 CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。
2.假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个 CPU 一次只能运行一个任务。
3.进程就好比工厂的车间，它代表 CPU 所能处理的单个任务。任一时刻，CPU 总是运行一个进程，其他进程处于非运行状态。
4.一个车间里，可以有很多工人。他们协同完成一个任务。
5.线程就好比车间里的工人。一个进程可以包括多个线程。
6.车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。
7.可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。
8.一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫&rdquo;互斥锁&rdquo;（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。
9.还有些房间，可以同时容纳 n 个人，比如厨房。也就是说，如果人数大于 n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。
10.这时的解决方法，就是在门口挂 n 把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做&rdquo;信号量&rdquo;（Semaphore），用来保证多个线程不会互相冲突。
进程  强调一个运行的状态：编写完毕的代码，在没有运行的时候，称之为程序。正在运行着的代码，就成为进程— 操作系统分配的一个基本单位：运行一个程序，就创作一个进程，操作系统分配资源。 隔离和共享： 进程内部共享资源，进程间不能直接共享资源  线程  线程是 CPU 调度和分派的基本单位：是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。如果把进程理解为在逻辑上操作系统所完成的任务，那么线程表示完成该任务的许多可能的子任务之一。 它可与同属一个进程的其他的线程共享进程所拥有的全部资源， 常常多个线程共享资源时要加互斥锁，避免数据竞争状态的出现  进程线程对比 参考：进程与线程，单核与多核
联系：
 一个线程只能属于一个进程，而一个进程可以有多个线程，至少有一个线程。 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 处理机分给线程，即真正在处理机上运行的是线程。 线程在执行过程中，需要协作同步（加锁，通道）。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体.  区别：
 资源单位 1 ：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 资源 ：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源. 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。  不同 线程和进程对比
1) 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间 2) 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源 3) 线程是处理器调度的基本单位,但进程不是 4) 二者均可并发执行 5) 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序（进程）中， 由应用程序提供多个线程执行控制……
                            </div>
                            <p class="readmore"><a href="https://TomatoAres.github.io/posts/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://TomatoAres.github.io/posts/docker%E7%AE%80%E4%BB%8B/" title="Docker简介" >Docker简介</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年8月22日
                            </date>
                            
                            <div class="post-content">
                                是什么？  容器引擎——核心 开源 go编写 基于LXC(Linux Container)内核虚拟化实现  能干什么？  持续集成  简化配置 代码流水线管理 快速部署 提高开发效率  版本控制 可移植性 —— 可以移动到任意一台Docker主机上 标准性—— 容器保证所有配置依赖不变 隔离性与安全  和虚拟机比的优势  轻量 M G —— 资源都是钱 性能高  共享主机内核， 没有Hypervisor 层开销
 系统级虚拟化， 占用资源少  使用更加方便  配置简单——标准化 要求低，不需要CPU虚拟化技术支持   虚拟机也有优势  安全性好——docker只是进程级别的隔离，虚拟机是物理层面的隔离 有自己完整的操作系统  涉及到的技术  LXC: Linux容器技术，共享内核 Cgroups ：control groups  内核提供的限制资源的技术（CPU，内存）  namespace：隔离技术：  UTS—— 每个容器可以有自己的 hostname 和 domainame IPC——进程间通信 每个容器有其自己的 System V IPC 和 POSIX 消息队列文件系统，因此，只有在同一个 IPC namespace 的进程之间才能互相通信 PID——进程 每个 PID namespace 中的进程可以有其独立的 PID Network、每个容器用有其独立的网络设备，IP 地址，IP 路由表， Mount——每个容器能看到不同的文件系统层次结构 User 每个 container 可以有不同的 user 和 group id  AUFS（advanced multi layered unification filesystem）：高级多层统一文件系统，是UFS的一种  docker engine 关键词：洋葱模型，cs架构……
                            </div>
                            <p class="readmore"><a href="https://TomatoAres.github.io/posts/docker%E7%AE%80%E4%BB%8B/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://TomatoAres.github.io/posts/channel/" title="channel 总结" >channel 总结</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年8月21日
                            </date>
                            
                            <div class="post-content">
                                1. 声明和类型 ChannelType = ( &quot;chan&quot; | &quot;chan&quot; &quot;&lt;-&quot; | &quot;&lt;-&quot; &quot;chan&quot; ) ElementType . 声明 双向：var ReadAndWriteChannel chan int 仅可读：var OnlyReadChannel &lt;- chan int 仅可写：var OnlyWriteChannel chan &lt;- int  初始化： make(chan int) //坑：没有数据，读取阻塞，直至写入数据 make(chan int,100) // 容量 缓存 buffer  2. 操作 c := make(chan int) 读:i := &lt;- c 写: c &lt;- (7+2) 遍历: range c 关闭: close(c) 坑：关闭channel，可读，不可写（panic） 多值接收：判断是否关闭 x,ok := &lt;-c //（ok == false 关闭）  阻塞情况一览 这些阻塞可能引起 deadlock——阻塞致死……
                            </div>
                            <p class="readmore"><a href="https://TomatoAres.github.io/posts/channel/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://TomatoAres.github.io/posts/tcp-udp/" title="TCP UDP 总结" >TCP UDP 总结</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年8月18日
                            </date>
                            
                            <div class="post-content">
                                 UDP 用户数据报协议，是一个无连接的简单的面向数据报的运输层协议。 UDP 不提供可靠性，它只是把应用程序传给 IP 层的数据报发送出去，但是并不能保证它们能到达目的地。由于 UDP 在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。
UDP 特点  无连接：UDP 是面向无连接的通讯协议，UDP 数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。 大小限制：UDP 传输数据时有大小限制，每个被传输的数据报必须限定在 64KB 之内。 不可靠： UDP 是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。  应用：注重速度流畅的业务 UDP 是面向消息的协议，通信时不需要建立连接，数据的传输自然是不可靠的，UDP 一般用于多点通信和实时的数据业务，比如
语音广播 视频 QQ TFTP（简单文件传送） SNMP（简单网络管理协议） RIP（路由信息协议，如报告股票市场，航空信息） DNS（域名解释）  UDP 构建步骤 客户端
 Socket 创建客户端套接字 sendto/recvfrom 发送/接收数据 close 关闭套接字  服务端
 Socket bind recvfrom/sendto  TCP TCP 服务器构建  socket 创建一个套接字 bind 绑定 ip 和 port listen 使套接字变为可以被动链接 accept 等待客户端的链接 recv/send 接收发送数据  ……
                            </div>
                            <p class="readmore"><a href="https://TomatoAres.github.io/posts/tcp-udp/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://TomatoAres.github.io/posts/influxdb%E7%AE%80%E4%BB%8B/" title="Influxdb 简介" >Influxdb 简介</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年8月18日
                            </date>
                            
                            <div class="post-content">
                                 概述  使用 GO 语言开发 开源 时序数据库：适合用于处理和分析资源监控数据这种时序相关数据 SQL-like 语法  三大特性：
 时序性（Time Series）：与时间相关的函数的灵活使用（诸如最大、最小、求和等）； 度量（Metrics）：对实时大量数据进行计算； 事件（Event）：支持任意的事件数据，换句话说，任意事件的数据我们都可以做操作。  其他特性：
 无结构：schemaless(无结构)，可以是任意数量的列； 度量方便：min, max, sum, count, mean, median 一系列函数，方便统计； 支持 http：Native HTTP API, 内置 http 支持，使用 http 读写； 查询语法简单：Powerful Query Language 类似 sql； 管理方便：Built-in Explorer 自带管理工具。  概念 数据库相关名词
 database：数据库； measurement：数据库中的表； points：表里面的一行数据。  特有名词：
Point 由时间戳（time）、数据（field）和标签（tags）组成。
 time：每条数据记录的时间，也是数据库自动生成的主索引； fields：各种记录的值； tags：各种有索引的属性。  ……
                            </div>
                            <p class="readmore"><a href="https://TomatoAres.github.io/posts/influxdb%E7%AE%80%E4%BB%8B/">阅读全文</a></p>
                        </article>
                    
                    



<ol class="page-navigator">
    
    <li class="prev">
        <a href="https://TomatoAres.github.io/page/2/">上一页</a>
    </li>
    

    
    <li >
        <a href="https://TomatoAres.github.io/">1</a>
    </li>
    
    <li >
        <a href="https://TomatoAres.github.io/page/2/">2</a>
    </li>
    
    <li  class="current">
        <a href="https://TomatoAres.github.io/page/3/">3</a>
    </li>
    
    <li >
        <a href="https://TomatoAres.github.io/page/4/">4</a>
    </li>
    

    
    <li class="next">
        <a href="https://TomatoAres.github.io/page/4/">下一页</a>
    </li>
    
</ol>



                </div>
            </div>

            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://TomatoAres.github.io/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://TomatoAres.github.io/posts/rpc-%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/" title="Rpc 标准库的几种实现方式">Rpc 标准库的几种实现方式</a>
    </li>
    
    <li>
        <a href="https://TomatoAres.github.io/posts/go-%E8%A7%A3%E6%9E%90%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E6%B3%A8%E6%84%8F%E7%82%B9/" title="Go xml json 小结">Go xml json 小结</a>
    </li>
    
    <li>
        <a href="https://TomatoAres.github.io/posts/go-struct-tag-%E6%98%AF%E6%80%8E%E4%B9%88%E7%8E%A9%E7%9A%84/" title="Go Struct Tag 是怎么玩的">Go Struct Tag 是怎么玩的</a>
    </li>
    
    <li>
        <a href="https://TomatoAres.github.io/posts/mongodb-%E7%AE%80%E4%BB%8B/" title="MongoDB 简介">MongoDB 简介</a>
    </li>
    
    <li>
        <a href="https://TomatoAres.github.io/posts/go-%E6%97%B6%E5%8C%BA%E8%AE%BE%E7%BD%AE/" title="Go 时区设置">Go 时区设置</a>
    </li>
    
    <li>
        <a href="https://TomatoAres.github.io/posts/%E6%97%A0%E7%8A%B6%E6%80%81-keep-alive%E7%9A%84%E5%8C%BA%E5%88%AB/" title="无状态 和 Keep Alive 的区别">无状态 和 Keep Alive 的区别</a>
    </li>
    
    <li>
        <a href="https://TomatoAres.github.io/posts/http-%E7%8A%B6%E6%80%81%E7%A0%81/" title="Http 状态码">Http 状态码</a>
    </li>
    
    <li>
        <a href="https://TomatoAres.github.io/posts/%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93-vs-%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93/" title="行数据库 vs 列数据库">行数据库 vs 列数据库</a>
    </li>
    
    <li>
        <a href="https://TomatoAres.github.io/posts/radix-tree-%E5%9F%BA%E6%95%B0%E6%A0%91/" title="Radix Tree 基数树">Radix Tree 基数树</a>
    </li>
    
    <li>
        <a href="https://TomatoAres.github.io/posts/byte-rune/" title="Go 中 Byte Rune">Go 中 Byte Rune</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://TomatoAres.github.io/tags/about/">about</a>
    
    <a href="https://TomatoAres.github.io/tags/container/">container</a>
    
    <a href="https://TomatoAres.github.io/tags/data-struct/">data-struct</a>
    
    <a href="https://TomatoAres.github.io/tags/database/">database</a>
    
    <a href="https://TomatoAres.github.io/tags/go/">go</a>
    
    <a href="https://TomatoAres.github.io/tags/hugo/">hugo</a>
    
    <a href="https://TomatoAres.github.io/tags/microservice/">microservice</a>
    
    <a href="https://TomatoAres.github.io/tags/network/">network</a>
    
    <a href="https://TomatoAres.github.io/tags/os/">os</a>
    
    <a href="https://TomatoAres.github.io/tags/test/">test</a>
    
    <a href="https://TomatoAres.github.io/tags/web/">web</a>
    
    <a href="https://TomatoAres.github.io/tags/%E7%AE%97%E6%B3%95/">算法</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://TomatoAres.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="https://TomatoAres.github.io/">西红柿的博客 By 战神西红柿</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>



<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>







</body>
</html>

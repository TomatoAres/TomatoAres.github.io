<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Network on 西红柿的博客</title>
    <link>https://tomatoares.github.io/tags/Network/</link>
    <description>Recent content in Network on 西红柿的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 22 Oct 2019 00:52:45 +0800</lastBuildDate><atom:link href="https://tomatoares.github.io/tags/Network/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Iperf3 小结</title>
      <link>https://tomatoares.github.io/posts/network/iperf/</link>
      <pubDate>Tue, 22 Oct 2019 00:52:45 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/network/iperf/</guid>
      <description>定义 iPerf3 是用于主动测量 IP 网络上可达到的最大带宽的工具。 它支持与时序，缓冲区和协议（TCP，UDP，带有 IPv4 和 IPv6 的 SCTP）相关的各种参数的调整。 对于每个测试，它都会报告带宽，损耗和其他参数。 不向后兼容——可以说已经不是 iperf 功能 基本——Iperf2 也有 TCP 和 UDP 测试 （-u） 设置端口（-p） 设</description>
    </item>
    
    <item>
      <title>OpenvSwitch 初探</title>
      <link>https://tomatoares.github.io/posts/network/openvswitch/</link>
      <pubDate>Tue, 22 Oct 2019 00:08:36 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/network/openvswitch/</guid>
      <description>定义 一句话：openvswitch 就是软件（虚拟）交换机。 Open vSwitch 是一个高质量的、多层虚拟交换机， 使用开源 Apache2.0 许可协议，由 Nicira Networks 开发，主要实现代码为可移植的 C 代码。 目的是让大规模网络自动化可以通过编程扩展，同时仍然支持标准的管理接口和协议（例如 NetFlow, sFlow, SPAN, RSPAN, CLI, LACP, 802.1ag）。 此外，它被设计</description>
    </item>
    
    <item>
      <title>单播 广播 组播</title>
      <link>https://tomatoares.github.io/posts/network/%E5%8D%95%E6%92%AD-%E5%B9%BF%E6%92%AD-%E5%A4%9A%E6%92%AD/</link>
      <pubDate>Fri, 27 Sep 2019 23:29:24 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/network/%E5%8D%95%E6%92%AD-%E5%B9%BF%E6%92%AD-%E5%A4%9A%E6%92%AD/</guid>
      <description>概念准备 只有 UDP 套接字允许广播或多播 无状态 无连接 使用 UDP 协议进行信息的传输之前不需要建议连接。换句话说就是客户端向服务器发送信息，客户端只需要给出服务器的 ip 地址和端口号，然后将信息封装到一个待发送的报文中并且发送出去。至于服务器端是否存在，或者能否收到该报文，客户端根本不用管。 单播用</description>
    </item>
    
    <item>
      <title>常见 IO 模型研究 </title>
      <link>https://tomatoares.github.io/posts/network/%E5%B8%B8%E8%A7%81-IO-%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Sun, 22 Sep 2019 14:13:45 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/network/%E5%B8%B8%E8%A7%81-IO-%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B6/</guid>
      <description>核心信息 IO 发生时涉及的对象和步骤。对于一个 network IO （这里我们以 read 举例），它会涉及到两个系统对象，一个是调用这个 IO 的 process (or thread)，另一个就是系统内核 (kernel)。当一个 read 操作发生时，它会经历两个阶段： 等待数据准备 (Waiting for the data to be ready) 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process) 记住这两</description>
    </item>
    
    <item>
      <title>Docker 网络 总结</title>
      <link>https://tomatoares.github.io/posts/cloud/docker-network/</link>
      <pubDate>Mon, 16 Sep 2019 23:32:37 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/cloud/docker-network/</guid>
      <description>4 种模式 bridge：默认网络， Docker 启动后创建一个 docker0 网桥，默认创建的容器也是添加到这个网桥中； IP 地址段是 172.17.0.1/16 host：容器不会获得一个独立的 network namespace，而是与宿主机共用一个。 none：获取独立的 network namespace，但不为容器进行任何网络配置。 创建 docker run &amp;ndash;network none 无 ip mac 等配置 仅 exec 方</description>
    </item>
    
    <item>
      <title>Rpc 标准库的几种实现方式</title>
      <link>https://tomatoares.github.io/posts/network/rpc-%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 12 Sep 2019 11:43:50 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/network/rpc-%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</guid>
      <description>server server.go package main import ( &amp;#34;errors&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;net&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;net/rpc&amp;#34; ) type Args struct { A, B int } type Quotient struct { Quo, Rem int } type Arith int func (t *Arith) Multiply(args *Args, reply *int) error { *reply = args.A * args.B return nil } func (t *Arith) Divide(args *Args, quo *Quotient) error { if args.B == 0 { return errors.New(&amp;#34;divide by zero&amp;#34;) } quo.Quo = args.A / args.B quo.Rem = args.A % args.B return nil } func main() { arith := new(Arith) rpc.Register(arith) rpc.HandleHTTP() // http 实现 err := http.ListenAndServe(&amp;#34;:1234&amp;#34;, nil) // http rpc 监听 if err != nil { fmt.Println(err.Error()) } } // TCP 实现 //func main() { // arith := new(Arith) // rpc.Register(arith) // tcpAddr, err := net.ResolveTCPAddr(&amp;#34;tcp&amp;#34;, &amp;#34;:1234&amp;#34;) // checkError(err) // listener, err := net.ListenTCP(&amp;#34;tcp&amp;#34;, tcpAddr) // checkError(err) // for</description>
    </item>
    
    <item>
      <title>TCP 总结</title>
      <link>https://tomatoares.github.io/posts/network/TCP-%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 29 Aug 2019 00:52:58 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/network/TCP-%E6%80%BB%E7%BB%93/</guid>
      <description>通信过程 ![通信过程](/image/network/tcp 通信过程。png) 服务端： socket：建立 socket bind：绑定服务端 ip listen：开始监听 accept：等待连接（阻塞） read/write：通信 close：关闭连接 三次握手——建立通信过程 参考：TCP 的三次握手与四次挥</description>
    </item>
    
    <item>
      <title>TCP UDP 总结</title>
      <link>https://tomatoares.github.io/posts/network/tcp-udp/</link>
      <pubDate>Sun, 18 Aug 2019 23:30:07 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/network/tcp-udp/</guid>
      <description>UDP 用户数据报协议，是一个无连接的简单的面向数据报的运输层协议。 UDP 不提供可靠性，它只是把应用程序传给 IP 层的数据报发送出去，但是并不能保证它们能到达目的地。由于 UDP 在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。 UDP 特点 无连接：UDP 是面向无连接</description>
    </item>
    
  </channel>
</rss>

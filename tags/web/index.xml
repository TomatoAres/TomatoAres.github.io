<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Web on 西红柿的博客</title>
    <link>https://tomatoares.github.io/tags/Web/</link>
    <description>Recent content in Web on 西红柿的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 11 Sep 2019 18:56:33 +0800</lastBuildDate><atom:link href="https://tomatoares.github.io/tags/Web/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>登录状态保持的发展——session，token</title>
      <link>https://tomatoares.github.io/posts/web/%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8C%81%E7%9A%84%E5%8F%91%E5%B1%95/</link>
      <pubDate>Wed, 11 Sep 2019 18:56:33 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/web/%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8C%81%E7%9A%84%E5%8F%91%E5%B1%95/</guid>
      <description>根本原因 http 是无状态的协议 以后能从这根本上解决吗？ 1.很久以前：没有这个需求 很久很久以前，Web 基本上就是文档的浏览而已，既然是浏览，作为服务器，不需要记录谁在某一段时间里都浏览了什么文档，每次请求都是一个新的 HTTP 协议， 就是请求加响应， 尤其是我不用记住是谁刚刚发了 HTTP 请求， 每个请求对我</description>
    </item>
    
    <item>
      <title>防止多次重复提交表单</title>
      <link>https://tomatoares.github.io/posts/web/%E9%98%B2%E6%AD%A2%E5%A4%9A%E6%AC%A1%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95/</link>
      <pubDate>Wed, 11 Sep 2019 17:50:46 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/web/%E9%98%B2%E6%AD%A2%E5%A4%9A%E6%AC%A1%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95/</guid>
      <description>解决方案 1 是在表单中添加一个带有唯一值的隐藏字段。在验证表单时，先检查带有该惟一值的表单是否已经递交过了。如果是，拒绝再次递交；如果不是，则处理表单进行逻辑处理。 解决方案 2 如果是采用了 Ajax 模式递交表单的话，当表单递交后，通过 javascript 来禁用表单的递交按钮</description>
    </item>
    
    <item>
      <title>无状态 和 Keep Alive 的区别</title>
      <link>https://tomatoares.github.io/posts/web/%E6%97%A0%E7%8A%B6%E6%80%81-keep-alive%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 10 Sep 2019 21:51:19 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/web/%E6%97%A0%E7%8A%B6%E6%80%81-keep-alive%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>无状态 = 无记忆 无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。 HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 HTTP 使用的是 UDP 协议（面对无连接）。 Keep alive 保持</description>
    </item>
    
    <item>
      <title>Http 状态码小结</title>
      <link>https://tomatoares.github.io/posts/web/http-%E7%8A%B6%E6%80%81%E7%A0%81/</link>
      <pubDate>Tue, 03 Sep 2019 16:14:53 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/web/http-%E7%8A%B6%E6%80%81%E7%A0%81/</guid>
      <description>HTTP 响应状态代码指示特定 HTTP 请求的 状态（是否完成）。 响应分为五类： 信息响应(100–199) 成功响应(200–299)， 重定向(300–399)， 客户端错误(400–499) 服务器错误 (500–599)。 信息响应节 100 Continue 这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求</description>
    </item>
    
    <item>
      <title>Csrf Xss 总结·对比</title>
      <link>https://tomatoares.github.io/posts/web/csrf-xss/</link>
      <pubDate>Mon, 02 Sep 2019 21:49:35 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/web/csrf-xss/</guid>
      <description>CSRF 是什么 CSRF（Cross-site request forgery）：跨站请求伪造。也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 CSRF 可以做什么？ 你这可以这么理解 CSRF 攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF 能够做的事情包括：以你名义发送邮件，发消息，盗取你的账</description>
    </item>
    
    <item>
      <title>Http 方法总结</title>
      <link>https://tomatoares.github.io/posts/web/http-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 02 Sep 2019 21:16:34 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/web/http-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>一、GET GET 方法通常用于获取资源。在 GET 请求中一般不会包含呈现数据（如 HTML 文本、图片、视频等）。 使用中发现： postman 和浏览器均无法携带 请求体 es 查询可以 二、HEAD 获取报文的首部。和 GET 方法是一样的，但是他不反悔报文实体的主体部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。 三、POST 一</description>
    </item>
    
    <item>
      <title>HTTP 2.0</title>
      <link>https://tomatoares.github.io/posts/web/HTTP-2.0/</link>
      <pubDate>Sat, 31 Aug 2019 17:55:36 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/web/HTTP-2.0/</guid>
      <description>HTTP/2 (原本的名字是 HTTP/2.0) 是万维网使用的 HTTP 网络协议的第二个主要版本。HTTP/2 提供了更快的速度和更好的用户体验。 特性 使用二进制格式传输数据，而不是文本。使得在解析和优化扩展上更为方便。 多路复用，所有的请求都是通过一个 TCP 连接并发完成。 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的</description>
    </item>
    
    <item>
      <title>Websocket 总结</title>
      <link>https://tomatoares.github.io/posts/web/websocket%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 31 Aug 2019 16:36:01 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/web/websocket%E6%80%BB%E7%BB%93/</guid>
      <description>是什么 WebSocket 是通过单个 TCP 连接提供全双工（双向通信）通信信道的计算机通信协议。 在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。——长链接，直到关闭 在 WebSocket 出现之前，为了实现即时通信，采用的技术都是“轮询”，即在特</description>
    </item>
    
    <item>
      <title>Restful 总结</title>
      <link>https://tomatoares.github.io/posts/web/restful%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 31 Aug 2019 16:24:33 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/web/restful%E6%80%BB%E7%BB%93/</guid>
      <description>是什么 REST(REpresentational State Transfer) 这个概念，首次出现是在 2000 年 Roy Thomas Fielding（他是 HTTP 规范的主要编写者之一）的博士论文中，它指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful 的。 要理解什么是 REST，我们需要理解下面几个概念： 资源（Resources） REST 是&amp;quot;表现层状</description>
    </item>
    
    <item>
      <title>Echo 框架的简单使用</title>
      <link>https://tomatoares.github.io/posts/web/echo/</link>
      <pubDate>Fri, 16 Aug 2019 16:57:56 +0800</pubDate>
      
      <guid>https://tomatoares.github.io/posts/web/echo/</guid>
      <description>本文是工作刚接触 go 语言，需要作分享时做的一份总结，重新整理的结果。 源码 特性概述 总的来说：轻量·高效 优化的 HTTP 路由器，巧妙地确定路由优先级 构建健壮且可伸缩的 RESTful API 组 API 可扩展的中间件框架 以根，组或路径级别定义中间件 JSON，XML 和表单的数据绑定 便捷地发送各种 HTTP 响应 集中的 HTTP 错误处理 可以使</description>
    </item>
    
  </channel>
</rss>

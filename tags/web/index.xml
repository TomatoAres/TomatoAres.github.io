<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>web on 西红柿的博客</title>
    <link>https://TomatoAres.github.io/tags/web/</link>
    <description>Recent content in web on 西红柿的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved - TomatoAres 2019</copyright>
    <lastBuildDate>Mon, 02 Sep 2019 21:49:35 +0800</lastBuildDate>
    
	<atom:link href="https://TomatoAres.github.io/tags/web/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Csrf Xss 总结</title>
      <link>https://TomatoAres.github.io/posts/csrf-xss/</link>
      <pubDate>Mon, 02 Sep 2019 21:49:35 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/csrf-xss/</guid>
      <description>CSRF 是什么 CSRF（Cross-site request forgery）：跨站请求伪造。
CSRF 的攻击原理 用户是网站 A 的注册用户，且登录进去，于是网站 A 就给用户下发 cookie。 从上图可以看出，要完成一次 CSRF 攻击，受害者必须满足两个必要的条件： （1）登录受信任网站 A，并在本地生成 Cookie。（如果用户没有登录网站 A，那么网站 B 在诱导的时候，请求网站 A 的 api 接口时，会提示你登录） （2）在不登出 A 的情况下，访问危险网站 B（其实是利用了网站 A 的漏洞）。
我们在讲 CSRF 时，一定要把上面的两点说清楚。 温馨提示一下，cookie 保证了用户可以处于登录状态，但网站 B 其实拿不到 cookie。
举个例子，前端事假你，微博网站有个 api 接口有漏洞，导致很多用户的粉丝暴增。
CSRF 如何防御 方法一、Token 验证：（用的最多） （1）服务器发送给客户端一个 token； （2）客户端提交的表单中带着这个 token。 （3）如果这个 token 不合法，那么服务器拒绝这个请求。
方法二：隐藏令牌 把 token 隐藏在 http 的 head 头中。 方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。
方法三、Referer 验证 Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。
XSS（Cross Site Scripting）：跨域脚本攻击 核心是 注入 恶意代码</description>
    </item>
    
    <item>
      <title>Http 方法总结</title>
      <link>https://TomatoAres.github.io/posts/http-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 02 Sep 2019 21:16:34 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/http-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>一、GET GET 方法通常用于获取资源。在 GET 请求中一般不会包含呈现数据（如 HTML 文本、图片、视频等）。
使用中发现：
 postman 和浏览器均无法携带 请求体 es 查询可以  二、HEAD 获取报文的首部。和 GET 方法是一样的，但是他不反悔报文实体的主体部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。
三、POST 一般用于传输实体主体，主要用来传输数据。
GET 和 POST 的区别
 作用: GET 主要用来获取资源、POST 主要用来传输实体主体（数据）。 参数:GET 和 POST 的请求都能使用额外参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在请求体中。
/**GET方式**/ GET /test/demo_form.asp?name1=value1&amp;amp;name2=value2 HTTP/1.1 /**POST方式**/ POST /test/demo_form.asp HTTP/1.1 Host: w3schools.com name1=value1&amp;amp;name2=value2   注意：
 但是不能因为 POST 参数存储在实体主体中就认为它的安全性高，因为照样可以通过一些抓包工具（如：Fiddler）查看。 因为 URL 只支持 ASCII 码，因此 GET 中的参数如果存在中文等字符就需要先进行编码，在服务器进行解码。POST 请求支持标准字符集。  四、PUT 一般用于上传文件，由于 PUT 方法本身不带验证机制，任何人都可以上传文件，因此存在安全问题，一般我们不使用此方法。</description>
    </item>
    
    <item>
      <title>HTTP 2.0</title>
      <link>https://TomatoAres.github.io/posts/http-2.0/</link>
      <pubDate>Sat, 31 Aug 2019 17:55:36 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/http-2.0/</guid>
      <description>HTTP/2 (原本的名字是 HTTP/2.0) 是万维网使用的 HTTP 网络协议的第二个主要版本。HTTP/2 提供了更快的速度和更好的用户体验。
特性  使用二进制格式传输数据，而不是文本。使得在解析和优化扩展上更为方便。 多路复用，所有的请求都是通过一个 TCP 连接并发完成。 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量。 Server Push：服务端能够更快的把资源推送给客户端。  参考：让面试官颤抖的 HTTP 2.0 协议面试题</description>
    </item>
    
    <item>
      <title>Restful 总结</title>
      <link>https://TomatoAres.github.io/posts/restful%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 31 Aug 2019 16:24:33 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/restful%E6%80%BB%E7%BB%93/</guid>
      <description>是什么  基于 HTTP 开发 web 服务 一种规范,说是一种风格可能更合适——可遵守，可不遵守 资源 和 uri 绑定 增删改查对应 HTTP 的四种方法 —— GET,POST,PUT,DELETE  好处  规范化设计 可读性  使用 接口命名规则：http://IP:端口/app-name/rest/v/接口名（资源名）/param
工作中遇到的问题 批量删除 用的 post 解决的，携带数组，或者在查询参赛携带 delete=all</description>
    </item>
    
    <item>
      <title>Echo 的简单使用</title>
      <link>https://TomatoAres.github.io/posts/echo/</link>
      <pubDate>Fri, 16 Aug 2019 16:57:56 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/echo/</guid>
      <description>echo框架的简单使用 本文是工作刚接触 go 语言，需要作分享时做的一份总结，重新整理的结果。
源码
特性概述 总的来说：轻量·高效
 优化的HTTP路由器，巧妙地确定路由优先级
 构建健壮且可伸缩的RESTful API
 组API
 可扩展的中间件框架
 以根，组或路径级别定义中间件
 JSON，XML和表单的数据绑定
 便捷地发送各种HTTP响应
 集中的HTTP错误处理
 可以使用任何模板引擎
 自定义logger
 高度可定制
 从 Let’s Encrypt（第三方网站）自动加载TLS
 HTTP / 2支持
  简单例子：helloworld package main import ( &amp;quot;net/http&amp;quot; &amp;quot;github.com/labstack/echo&amp;quot; &amp;quot;github.com/labstack/echo/middleware&amp;quot; ) func main() { //创建echo对象 e := echo.New() //中间件 e.Use(middleware.Logger()) e.Use(middleware.Recover()) //路由route 映射 handler（函数） e.GET(&amp;quot;/&amp;quot;, func(c echo.Context) error { return c.String(http.StatusOK, &amp;quot;Hello, World!</description>
    </item>
    
  </channel>
</rss>
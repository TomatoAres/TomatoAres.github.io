<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="pinterest" content="nopin">
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.56.3" />

<link rel="alternate" type="application/rss+xml" title="RSS" href="https://TomatoAres.github.io/tags/go/index.xml">

<link rel="canonical" href="https://TomatoAres.github.io/tags/go/">


    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_dark.min.css">
    <title>go - 西红柿的博客</title>
    
    <link href="https://TomatoAres.github.io/css/styles.css" rel="stylesheet">
    

  </head>

  <body>
    
    
    

    <header class="l-header">
      <nav class="navbar navbar-default">
        <div class="container">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://TomatoAres.github.io/">西红柿的博客</a>
          </div>

          
          <div id="navbar" class="collapse navbar-collapse">
            
            <ul class="nav navbar-nav navbar-right">
              
              
              <li><a href="https://TomatoAres.github.io/posts/about/">About</a></li>
              
              
              
              <li><a href="https://TomatoAres.github.io/">Home</a></li>
              
              
            </ul>
            
          </div>
          

        </div>
      </nav>
    </header>

    <main>
      <div class="container">
        
<div class="row">
  <div class="col-md-8">

    
    <header class="page-header">
      <h1>go</h1>
    </header>
    

    <ul class="p-articles">
      
      <li><article class="li">
  <header>
    <ul class="p-facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2019-09-11T19:45:08JST">Sep 11, 2019</time></li>
      <li><i class="fa fa-bookmark" aria-hidden="true"></i><a href="https://TomatoAres.github.io/posts/">posts</a></li>
      
    </ul>
    <h2 class="title"><a href="https://TomatoAres.github.io/posts/go-%E8%A7%A3%E6%9E%90%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E6%B3%A8%E6%84%8F%E7%82%B9/">Go xml json 小结</a></h2>
  </header>

  
  <div class="summary">最常见错误 struct 字段小写，序列化反序列化都无法访问——无法外部访问
解析 XML，反序列化，Unmarshal  如果 struct 的一个字段是 string 或者[]byt 类型且它的 tag 含有&rdquo;,inner xml &ldquo;，Unmarshal 将会将此字段所对应的元素内所有内嵌的原始 xml 累加到此字段上 比如下边例子中的 description，最终输出为：
&lt;server&gt; &lt;serverName&gt;Shanghai_VPN&lt;/serverName&gt; &lt;serverIP&gt;127.0.0.1&lt;/serverIP&gt; &lt;/server&gt; &lt;server&gt; &lt;serverName&gt;Beijing_VPN&lt;/serverName&gt; &lt;serverIP&gt;127.0.0.2&lt;/serverIP&gt; &lt;/server&gt;  如果 struct 中有一个叫做 XMLName(必须是这个)，且类型为 xml .Name 字段，那么在解析的时候就会保存这个 element 的名字到该字段,如下例子中的 servers 。
  如果某个 struct 字段的 tag 定义中含有 XML 结构中 element 的名称，那么解析的时候就会把相应的 element 值赋值给该字段，如下 servername 和 serverip 定义。 如果某个 struct 字段的 tag 定义了中含有&rdquo;,attr&rdquo;，那么解析的时候就会将该结构所对应的 element 的与字段同名的属性的值赋值给该字段，如下 version 定义。 如果某个 struct 字段的 tag 定义 型如&rdquo;a&gt;b&gt;c&rdquo;,则解析的时候，会将 xml 结构 a 下面的 b 下面的 c 元素的值赋值给该字段。 如果某个 struct 字段的 tag 定义了&rdquo;-&ldquo;,那么不会为该字段解析匹配任何 xml 数据。 如果 struct 字段后面的 tag 定义了&rdquo;,any&rdquo;，如果他的子元素在不满足其他的规则的时候就会匹配到这个字段。 如果某个 XML 元素包含一条或者多条注释，那么这些注释将被累加到第一个 tag 含有&rdquo;,comments&rdquo;的字段上，这个字段的类型可能是[]byte 或 string,如果没有这样的字段存在，那么注释将会被抛弃。  只要设置对了 tag，那么 XML 解析就如上面示例般简单，tag 和 XML 的 element 是一一对应的关系， 如下所示，我们还可以通过 slice 来表示多个同级元素。</div>

  
  <footer>
    <a href="https://TomatoAres.github.io/posts/go-%E8%A7%A3%E6%9E%90%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E6%B3%A8%E6%84%8F%E7%82%B9/" title="Go xml json 小结">Read More…</a>
  </footer>
  
</article>
</li>
      
      <li><article class="li">
  <header>
    <ul class="p-facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2019-09-11T19:31:18JST">Sep 11, 2019</time></li>
      <li><i class="fa fa-bookmark" aria-hidden="true"></i><a href="https://TomatoAres.github.io/posts/">posts</a></li>
      
    </ul>
    <h2 class="title"><a href="https://TomatoAres.github.io/posts/go-struct-tag-%E6%98%AF%E6%80%8E%E4%B9%88%E7%8E%A9%E7%9A%84/">Go Struct Tag 是怎么玩的</a></h2>
  </header>

  
  <div class="summary">利用 go 反射机制，通过 不同的 tag name 进行不同的处理
package main import ( &quot;fmt&quot; &quot;reflect&quot; // 这里引入reflect模块 ) // 自定义 tag const tagName = &quot;validate&quot; type employee struct { ID int `json:&quot;id&quot;` Name string `json:&quot;名字&quot; validate:&quot;presence,min=2,max=40&quot;` Age int `json:&quot;年龄&quot;` Desc string `json:&quot;描述&quot; back:&quot;好看否&quot;` weight float64 `json:&quot;weight&quot; 单位:&quot;kg&quot;` Salary float64 `json:&quot;-&quot;` Email string `validate:&quot;email,required&quot;` MateName string `json:&quot;mate_name,omitempty&quot;` } func test2() { zhangsan := employee{ ID: 1, Name: &quot;张三&quot;, Age: 18, Desc: &quot;秀色可餐&quot;, weight: 48.</div>

  
  <footer>
    <a href="https://TomatoAres.github.io/posts/go-struct-tag-%E6%98%AF%E6%80%8E%E4%B9%88%E7%8E%A9%E7%9A%84/" title="Go Struct Tag 是怎么玩的">Read More…</a>
  </footer>
  
</article>
</li>
      
      <li><article class="li">
  <header>
    <ul class="p-facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2019-09-11T16:17:20JST">Sep 11, 2019</time></li>
      <li><i class="fa fa-bookmark" aria-hidden="true"></i><a href="https://TomatoAres.github.io/posts/">posts</a></li>
      
    </ul>
    <h2 class="title"><a href="https://TomatoAres.github.io/posts/go-%E6%97%B6%E5%8C%BA%E8%AE%BE%E7%BD%AE/">Go 时区设置</a></h2>
  </header>

  
  <div class="summary">获取 time 对象 设置时区 按设置的时区输出
package main import ( &quot;fmt&quot; &quot;time&quot; ) func main() { now := time.Now() // 1. 获取 time 对象 // 2. 设置时区 local1, err1 := time.LoadLocation(&quot;&quot;) //等同于&quot;UTC&quot; if err1 != nil { fmt.Println(err1) } local2, err2 := time.LoadLocation(&quot;Local&quot;)//本地的时区 if err2 != nil { fmt.Println(err2) } local3, err3 := time.LoadLocation(&quot;America/Los_Angeles&quot;) if err3 != nil { fmt.Println(err3) } // 3. 按设置的时区输出 fmt.Println(now.In(local1)) fmt.Println(now.In(local2)) fmt.Println(now.In(local3)) } // out: // 2019-09-11 08:15:38.</div>

  
  <footer>
    <a href="https://TomatoAres.github.io/posts/go-%E6%97%B6%E5%8C%BA%E8%AE%BE%E7%BD%AE/" title="Go 时区设置">Read More…</a>
  </footer>
  
</article>
</li>
      
      <li><article class="li">
  <header>
    <ul class="p-facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2019-09-02T23:03:44JST">Sep 2, 2019</time></li>
      <li><i class="fa fa-bookmark" aria-hidden="true"></i><a href="https://TomatoAres.github.io/posts/">posts</a></li>
      
    </ul>
    <h2 class="title"><a href="https://TomatoAres.github.io/posts/byte-rune/">Go 中 Byte Rune</a></h2>
  </header>

  
  <div class="summary">byte 实质上就是 uint8 类型。byte 用来强调数据是 raw data，而不是数字； rune 实质上就是 int32 类型。而 rune 用来表示 Unicode 的 code point。
uint8 the set of all unsigned 8-bit integers (0 to 255) int32 the set of all signed 32-bit integers (-2147483648 to 2147483647) byte alias for uint8 rune alias for int32  // byte is an alias for uint8 and is equivalent to uint8 in all ways. It is // used, by convention, to distinguish byte values from 8-bit unsigned // integer values.</div>

  
  <footer>
    <a href="https://TomatoAres.github.io/posts/byte-rune/" title="Go 中 Byte Rune">Read More…</a>
  </footer>
  
</article>
</li>
      
      <li><article class="li">
  <header>
    <ul class="p-facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2019-09-02T21:07:29JST">Sep 2, 2019</time></li>
      <li><i class="fa fa-bookmark" aria-hidden="true"></i><a href="https://TomatoAres.github.io/posts/">posts</a></li>
      
    </ul>
    <h2 class="title"><a href="https://TomatoAres.github.io/posts/go-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/">Go 逃逸分析</a></h2>
  </header>

  
  <div class="summary"> 参考：Go 逃逸分析
堆和栈 要理解什么是逃逸分析会涉及堆和栈的一些基本知识，如果忘记的同学我们可以简单的回顾一下：
 堆（Heap）：一般来讲是人为手动进行管理，手动申请、分配、释放。 堆适合不可预知大小的内存分配，这也意味着为此付出的代价是分配速度较慢，而且会形成内存碎片。 栈（Stack）：由编译器进行管理，自动申请、分配、释放。 一般不会太大，因此栈的分配和回收速度非常快；我们常见的函数参数（不同平台允许存放的数量不同），局部变量等都会存放在栈上。 栈分配内存只需要两个 CPU 指令：“PUSH”和“RELEASE”，分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。  通俗比喻的说，
 栈就如我们去饭馆吃饭，只需要点菜（发出申请）&ndash;》吃吃吃（使用内存）&ndash;》吃饱就跑剩下的交给饭馆（操作系统自动回收）， 而堆就如在家里做饭，大到家，小到买什么菜，每一个环节都需要自己来实现，但是自由度会大很多。 在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针  逃逸分析 再往简单的说，Go 是通过在编译器里做逃逸分析（escape analysis）来决定一个对象放栈上还是放堆上，不逃逸的对象放栈上，可能逃逸的放堆上；即我发现变量在退出函数后没有用了，那么就把丢到栈上，毕竟栈上的内存分配和回收比堆上快很多；反之，函数内的普通变量经过逃逸分析后，发现在函数退出后变量还有在其他地方上引用，那就将变量分配在堆上。做到按需分配（哪里的人民需要我，我就往哪去~~，一个党员的呐喊）。
为何需要逃逸分析 ok，了解完堆和栈各自的优缺点后，我们就可以更好的知道逃逸分析存在的目的了：
 减少 gc 压力，栈上的变量，随着函数退出后系统直接回收，不需要 gc 标记后再清除。 减少内存碎片的产生。 减轻分配堆内存的开销，提高程序的运行速度。  如何确定是否逃逸 在 Go 中通过逃逸分析日志来确定变量是否逃逸，开启逃逸分析日志：
go run -gcflags '-m -l' main.go   -m 会打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 -m，但是信息量较大，一般用 1 个就可以了。 -l 会禁用函数内联，在这里禁用掉内联能更好的观察逃逸情况，减少干扰。  </div>

  
</article>
</li>
      
      <li><article class="li">
  <header>
    <ul class="p-facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2019-09-02T20:39:15JST">Sep 2, 2019</time></li>
      <li><i class="fa fa-bookmark" aria-hidden="true"></i><a href="https://TomatoAres.github.io/posts/">posts</a></li>
      
    </ul>
    <h2 class="title"><a href="https://TomatoAres.github.io/posts/heap-stack/"> Go 堆栈的理解</a></h2>
  </header>

  
  <div class="summary">来源：Go 堆栈的理解
在讲 Go 的堆栈之前，先温习一下堆栈基础知识。
什么是堆栈？在计算机中堆栈的概念分为：数据结构的堆栈和内存分配中堆栈。
数据结构的堆栈：
堆：堆可以被看成是一棵树，如：堆排序。在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。
栈：一种先进后出的数据结构。
这里着重讲的是内存分配中的堆和栈。
内存分配中的堆和栈
栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。
堆栈缓存方式 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。
堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。
堆栈跟踪 下面讨论堆栈跟踪信息以及如何在堆栈中识别函数所传递的参数。
以下测试案例的版本是Go 1.11
示例：
package main import &quot;runtime/debug&quot; func main() { slice := make([]string, 2, 4) Example(slice, &quot;hello&quot;, 10) } func Example(slice []string, str string, i int) { debug.PrintStack() }  列表1是一个简单的程序， main函数在第5行调用Example函数。Example函数在第9行声明，它有三个参数，一个字符串slice,一个字符串和一个整数。它的方法体也很简单，只有一行，debug.PrintStack（），这会立即产生一个堆栈跟踪信息:
goroutine 1 [running]: runtime/debug.Stack(0x1, 0x0, 0x0) C:/Go/src/runtime/debug/stack.go:24 +0xae runtime/debug.PrintStack() C:/Go/src/runtime/debug/stack.go:16 +0x29 main.Example(0xc000077f48, 0x2, 0x4, 0x4abd9e, 0x5, 0xa) D:/gopath/src/example/example/main.</div>

  
  <footer>
    <a href="https://TomatoAres.github.io/posts/heap-stack/" title=" Go 堆栈的理解">Read More…</a>
  </footer>
  
</article>
</li>
      
      <li><article class="li">
  <header>
    <ul class="p-facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2019-09-02T19:39:18JST">Sep 2, 2019</time></li>
      <li><i class="fa fa-bookmark" aria-hidden="true"></i><a href="https://TomatoAres.github.io/posts/">posts</a></li>
      
    </ul>
    <h2 class="title"><a href="https://TomatoAres.github.io/posts/gc-go/">Go GC </a></h2>
  </header>

  
  <div class="summary">参考：GO GC 垃圾回收机制
Go 作为一门高级语言，具有 自动垃圾回收 的功能。
常见垃圾回收机制 1. 引用计数：引用计数通过在对象上增加自己被引用的次数，被其他对象引用时加 1，引用自己的对象被回收时减 1，引用数为 0 的对象即为可以被回收的对象 优点： 1. 方式简单，回收速度快。
缺点： 1. 需要额外的空间存放计数。 2.无法处理循环引用（如 a.b=b;b.a=a 这种情况）。 3.频繁更新引用计数降低了性能。
2. 标记-清除（mark and sweep）：对引用对象进行标记，清除未引用对象（需要两次扫描） 步骤：
 标记从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”； 标记完成后进行清除操作，对没有标记过——即没有引用过的内存进行回收（回收同时可能伴有碎片整理操作）。  优点： 解决了引用计数的缺点 1 节约了内存，2 解决了循环引用的问题
缺点： 每次启动垃圾回收都会暂停当前所有的正常代码执行，回收是系统响应能力大大降低！
优化方式： mark&amp;sweep 算法的变种（如三色标记法）
3. 复制收集：新空间复制引用的对象，清除旧空间 过程： 准备一个「新的空间」，从根开始，对对象进行扫，如果存在对这个对象的引用，就把它复制到「新空间中」。一次扫描结束之后，所有存在于「新空间」的对象就是所有的非垃圾对象。
优点： 只需要对对象进行一次扫描。
4. 分代收集（generation）：根据存活时间 分代——新生代和老年代 默认 大部分对象的声明周期很短——新生代为主，小回收垃圾少
关键过程：
 新创建的对象存放在称为 新生代（young generation）中 ——一般来说，新生代的大小会比 老年代小很多。 高频对新生成的对象进行回收，称为「小回收」，低频对所有对象回收，称为「大回收」。 每一次「小回收」过后，就把存活下来的对象归为老年代，「小回收」的时候，遇到老年代直接跳过。大多数分代回收算法都采用的「复制收集」方法，因为小回收中垃圾的比例较大。  新问题： 老年代对新生代引用，还能进行小回收吗？
解决：这里用到了一中叫做写屏障的方式。
 程序对所有涉及修改对象内容的地方进行保护，被称为「写屏障」（Write Barrier）。写屏障不仅用于分代收集，也用于其他 GC 算法中。 在此算法的表现是  用一个记录集来记录从新生代到老生代的引用。 如果有两个对象 A （老生代） 和 B（新生代），当对 A 的对象内容进行修改并加入 B 的引用时。则将这个引用加入到记录集中。 「小回收」的时候，因为记录集中有对 B 的引用，所以 B 不再是垃圾   三色标记算法 三色标记算法是对标记阶段的改进——标记了两次（灰色，黑色），原理如下：</div>

  
  <footer>
    <a href="https://TomatoAres.github.io/posts/gc-go/" title="Go GC ">Read More…</a>
  </footer>
  
</article>
</li>
      
      <li><article class="li">
  <header>
    <ul class="p-facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2019-09-02T11:02:52JST">Sep 2, 2019</time></li>
      <li><i class="fa fa-bookmark" aria-hidden="true"></i><a href="https://TomatoAres.github.io/posts/">posts</a></li>
      
    </ul>
    <h2 class="title"><a href="https://TomatoAres.github.io/posts/gmp/">GMP</a></h2>
  </header>

  
  <div class="summary"></div>

  
</article>
</li>
      
      <li><article class="li">
  <header>
    <ul class="p-facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2019-08-29T01:44:15JST">Aug 29, 2019</time></li>
      <li><i class="fa fa-bookmark" aria-hidden="true"></i><a href="https://TomatoAres.github.io/posts/">posts</a></li>
      
    </ul>
    <h2 class="title"><a href="https://TomatoAres.github.io/posts/go-test/">go test 工具的简单介绍和使用</a></h2>
  </header>

  
  <div class="summary">简单介绍 go test 子命令是 Go 语言包的测试驱动程序，在一个包目录中，以*_test.go命名方式的文件，是go test编译的目标（不是go build）
在*_test.go 文件中，三种函数需要特殊对待，即功能测试函数、基准测试函数和示例函数：
 功能测试函数：以Test前缀命名的函数，用来检测一些程序逻辑的正确性 基准测试函数：以Benchmark开头，用来测试某些操作的性能 示例函数：以Example开头，用来提供机器检查过的文档 参考代码1 参考代码2  简单使用 Test函数 首先，在某一工程目录下创建两个文件：test.go(即源码文件)和test_test.go(即单元测试文件)，因为go test 命令只能在一个相应的目录下执行所有文件
test.go源码文件，创建一个test包，并实现一个除法运算 package test import ( &quot;errors&quot; ) func Division(a, b float64) (float64, error) { if b == 0 { return 0, errors.New(&quot;除数不能为0&quot;) } return a / b, nil }  test_test.go 测试单元文件  注意事项：
 文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码 你必须import testing这个包 测试用例会按照源代码中写的顺序依次执行 测试格式：func TestXxx (t *testing.T),Xxx部分可以为任意的字母数字的组合，但是首字母一定为大写字母 函数中通过调用testing.T的一些方法来说明测试通过或不通过： 调用t.Error()或t.Errorf()方法记录日志并标记测试失败,测试函数中的某条测试用例执行结果与预期不符时使用 Log和Logf方法用于日志输出，默认只输出错误日志，如果要输出全部日志需要使用-v Fail标记用例失败，但继续执行当前用例。FailNow标记用例失败并且立即停止执行当前用例，继续执行下一个（默认按书写顺序）用例 Error等价于Log加Fail，Errorf等价于Logf加Fail 使用t.</div>

  
  <footer>
    <a href="https://TomatoAres.github.io/posts/go-test/" title="go test 工具的简单介绍和使用">Read More…</a>
  </footer>
  
</article>
</li>
      
      <li><article class="li">
  <header>
    <ul class="p-facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2019-08-21T16:57:56JST">Aug 21, 2019</time></li>
      <li><i class="fa fa-bookmark" aria-hidden="true"></i><a href="https://TomatoAres.github.io/posts/">posts</a></li>
      
    </ul>
    <h2 class="title"><a href="https://TomatoAres.github.io/posts/channel/">channel 总结</a></h2>
  </header>

  
  <div class="summary">1. 声明和类型 ChannelType = ( &quot;chan&quot; | &quot;chan&quot; &quot;&lt;-&quot; | &quot;&lt;-&quot; &quot;chan&quot; ) ElementType . 声明 双向：var ReadAndWriteChannel chan int 仅可读：var OnlyReadChannel &lt;- chan int 仅可写：var OnlyWriteChannel chan &lt;- int  初始化： make(chan int) //坑：没有数据，读取阻塞，直至写入数据 make(chan int,100) // 容量 缓存 buffer  2. 操作 c := make(chan int) 读:i := &lt;- c 写: c &lt;- (7+2) 遍历: range c 关闭: close(c) 坑：关闭channel，可读，不可写（panic） 多值接收：判断是否关闭 x,ok := &lt;-c //（ok == false 关闭）  阻塞情况一览 这些阻塞可能引起 deadlock——阻塞致死</div>

  
  <footer>
    <a href="https://TomatoAres.github.io/posts/channel/" title="channel 总结">Read More…</a>
  </footer>
  
</article>
</li>
      
    </ul>

    
<nav>
  <ul class="pager">

    
    <li class="disabled"><a href="#">Previous</a></li>
    

    
    <li><a href="https://TomatoAres.github.io/tags/go/page/2/">Next</a></li>
    

  </ul>
</nav>



  </div>
  <div class="col-md-4">
    
<aside class="l-sidebar">

  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">LATESTS</div>
    </div>
    <div class="list-group">
      
      <a href="https://TomatoAres.github.io/posts/go-%E8%A7%A3%E6%9E%90%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E6%B3%A8%E6%84%8F%E7%82%B9/" class="list-group-item">Go xml json 小结</a>
      
      <a href="https://TomatoAres.github.io/posts/go-struct-tag-%E6%98%AF%E6%80%8E%E4%B9%88%E7%8E%A9%E7%9A%84/" class="list-group-item">Go Struct Tag 是怎么玩的</a>
      
      <a href="https://TomatoAres.github.io/posts/mongodb-%E7%AE%80%E4%BB%8B/" class="list-group-item">MongoDB 简介</a>
      
      <a href="https://TomatoAres.github.io/posts/go-%E6%97%B6%E5%8C%BA%E8%AE%BE%E7%BD%AE/" class="list-group-item">Go 时区设置</a>
      
      <a href="https://TomatoAres.github.io/posts/%E6%97%A0%E7%8A%B6%E6%80%81-keep-alive%E7%9A%84%E5%8C%BA%E5%88%AB/" class="list-group-item">无状态 和 Keep Alive 的区别</a>
      
      <a href="https://TomatoAres.github.io/posts/http-%E7%8A%B6%E6%80%81%E7%A0%81/" class="list-group-item">Http 状态码</a>
      
      <a href="https://TomatoAres.github.io/posts/%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93-vs-%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93/" class="list-group-item">行数据库 vs 列数据库</a>
      
      <a href="https://TomatoAres.github.io/posts/radix-tree-%E5%9F%BA%E6%95%B0%E6%A0%91/" class="list-group-item">Radix Tree 基数树</a>
      
      <a href="https://TomatoAres.github.io/posts/byte-rune/" class="list-group-item">Go 中 Byte Rune</a>
      
      <a href="https://TomatoAres.github.io/posts/csrf-xss/" class="list-group-item">Csrf Xss 总结</a>
      
    </div>
  </section>

  
  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">TAG</div>
    </div>
    <div class="list-group">
      
      <a href="https://TomatoAres.github.io/tags/go" class="list-group-item">go</a>
      
      <a href="https://TomatoAres.github.io/tags/web" class="list-group-item">web</a>
      
      <a href="https://TomatoAres.github.io/tags/database" class="list-group-item">database</a>
      
      <a href="https://TomatoAres.github.io/tags/hugo" class="list-group-item">hugo</a>
      
      <a href="https://TomatoAres.github.io/tags/microservice" class="list-group-item">microservice</a>
      
      <a href="https://TomatoAres.github.io/tags/network" class="list-group-item">network</a>
      
      <a href="https://TomatoAres.github.io/tags/test" class="list-group-item">test</a>
      
      <a href="https://TomatoAres.github.io/tags/about" class="list-group-item">about</a>
      
      <a href="https://TomatoAres.github.io/tags/container" class="list-group-item">container</a>
      
      <a href="https://TomatoAres.github.io/tags/data-struct" class="list-group-item">data-struct</a>
      
    </div>
  </section>
  
  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">TOPIC</div>
    </div>
    <div class="list-group">
      
    </div>
  </section>
  

</aside>


  </div>
</div>

      </div>
    </main>

    <footer class="l-footer">
      <div class="container">
        <p>All rights reserved - TomatoAres 2019</p>
        <aside>
          <p>Powered by <a href="https://gohugo.io/">Hugo</a>.</p>
          <p><a href="https://github.com/dim0627/hugo_theme_beg">Beg</a> designed by <a href="http://yet.unresolved.xyz/">Daisuke Tsuji</a>.</p>
        </aside>
      </div>
    </footer>

    <script src="//code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>


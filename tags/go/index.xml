<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on 西红柿的博客</title>
    <link>https://TomatoAres.github.io/tags/go/</link>
    <description>Recent content in go on 西红柿的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved - TomatoAres 2019</copyright>
    <lastBuildDate>Mon, 02 Sep 2019 23:03:44 +0800</lastBuildDate>
    
	<atom:link href="https://TomatoAres.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go 中 Byte Rune</title>
      <link>https://TomatoAres.github.io/posts/byte-rune/</link>
      <pubDate>Mon, 02 Sep 2019 23:03:44 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/byte-rune/</guid>
      <description>byte 实质上就是 uint8 类型。byte 用来强调数据是 raw data，而不是数字； rune 实质上就是 int32 类型。而 rune 用来表示 Unicode 的 code point。
uint8 the set of all unsigned 8-bit integers (0 to 255) int32 the set of all signed 32-bit integers (-2147483648 to 2147483647) byte alias for uint8 rune alias for int32  // byte is an alias for uint8 and is equivalent to uint8 in all ways. It is // used, by convention, to distinguish byte values from 8-bit unsigned // integer values.</description>
    </item>
    
    <item>
      <title>Go 逃逸分析</title>
      <link>https://TomatoAres.github.io/posts/go-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 02 Sep 2019 21:07:29 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/go-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</guid>
      <description> 参考：Go 逃逸分析
堆和栈 要理解什么是逃逸分析会涉及堆和栈的一些基本知识，如果忘记的同学我们可以简单的回顾一下：
 堆（Heap）：一般来讲是人为手动进行管理，手动申请、分配、释放。 堆适合不可预知大小的内存分配，这也意味着为此付出的代价是分配速度较慢，而且会形成内存碎片。 栈（Stack）：由编译器进行管理，自动申请、分配、释放。 一般不会太大，因此栈的分配和回收速度非常快；我们常见的函数参数（不同平台允许存放的数量不同），局部变量等都会存放在栈上。 栈分配内存只需要两个 CPU 指令：“PUSH”和“RELEASE”，分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。  通俗比喻的说，
 栈就如我们去饭馆吃饭，只需要点菜（发出申请）&amp;ndash;》吃吃吃（使用内存）&amp;ndash;》吃饱就跑剩下的交给饭馆（操作系统自动回收）， 而堆就如在家里做饭，大到家，小到买什么菜，每一个环节都需要自己来实现，但是自由度会大很多。 在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针  逃逸分析 再往简单的说，Go 是通过在编译器里做逃逸分析（escape analysis）来决定一个对象放栈上还是放堆上，不逃逸的对象放栈上，可能逃逸的放堆上；即我发现变量在退出函数后没有用了，那么就把丢到栈上，毕竟栈上的内存分配和回收比堆上快很多；反之，函数内的普通变量经过逃逸分析后，发现在函数退出后变量还有在其他地方上引用，那就将变量分配在堆上。做到按需分配（哪里的人民需要我，我就往哪去~~，一个党员的呐喊）。
为何需要逃逸分析 ok，了解完堆和栈各自的优缺点后，我们就可以更好的知道逃逸分析存在的目的了：
 减少 gc 压力，栈上的变量，随着函数退出后系统直接回收，不需要 gc 标记后再清除。 减少内存碎片的产生。 减轻分配堆内存的开销，提高程序的运行速度。  如何确定是否逃逸 在 Go 中通过逃逸分析日志来确定变量是否逃逸，开启逃逸分析日志：
go run -gcflags &#39;-m -l&#39; main.go   -m 会打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 -m，但是信息量较大，一般用 1 个就可以了。 -l 会禁用函数内联，在这里禁用掉内联能更好的观察逃逸情况，减少干扰。  </description>
    </item>
    
    <item>
      <title>Go GC </title>
      <link>https://TomatoAres.github.io/posts/gc-go/</link>
      <pubDate>Mon, 02 Sep 2019 19:39:18 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/gc-go/</guid>
      <description>参考：GO GC 垃圾回收机制
Go 作为一门高级语言，具有 自动垃圾回收 的功能。
常见垃圾回收机制 1. 引用计数：引用计数通过在对象上增加自己被引用的次数，被其他对象引用时加 1，引用自己的对象被回收时减 1，引用数为 0 的对象即为可以被回收的对象 优点： 1. 方式简单，回收速度快。
缺点： 1. 需要额外的空间存放计数。 2.无法处理循环引用（如 a.b=b;b.a=a 这种情况）。 3.频繁更新引用计数降低了性能。
2. 标记-清除（mark and sweep）：对引用对象进行标记，清除未引用对象（需要两次扫描） 步骤：
 标记从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”； 标记完成后进行清除操作，对没有标记过——即没有引用过的内存进行回收（回收同时可能伴有碎片整理操作）。  优点： 解决了引用计数的缺点 1 节约了内存，2 解决了循环引用的问题
缺点： 每次启动垃圾回收都会暂停当前所有的正常代码执行，回收是系统响应能力大大降低！
优化方式： mark&amp;amp;sweep 算法的变种（如三色标记法）
3. 复制收集：新空间复制引用的对象，清除旧空间 过程： 准备一个「新的空间」，从根开始，对对象进行扫，如果存在对这个对象的引用，就把它复制到「新空间中」。一次扫描结束之后，所有存在于「新空间」的对象就是所有的非垃圾对象。
优点： 只需要对对象进行一次扫描。
4. 分代收集（generation）：根据存活时间 分代——新生代和老年代 默认 大部分对象的声明周期很短——新生代为主，小回收垃圾少
关键过程：
 新创建的对象存放在称为 新生代（young generation）中 ——一般来说，新生代的大小会比 老年代小很多。 高频对新生成的对象进行回收，称为「小回收」，低频对所有对象回收，称为「大回收」。 每一次「小回收」过后，就把存活下来的对象归为老年代，「小回收」的时候，遇到老年代直接跳过。大多数分代回收算法都采用的「复制收集」方法，因为小回收中垃圾的比例较大。  新问题： 老年代对新生代引用，还能进行小回收吗？
解决：这里用到了一中叫做写屏障的方式。
 程序对所有涉及修改对象内容的地方进行保护，被称为「写屏障」（Write Barrier）。写屏障不仅用于分代收集，也用于其他 GC 算法中。 在此算法的表现是  用一个记录集来记录从新生代到老生代的引用。 如果有两个对象 A （老生代） 和 B（新生代），当对 A 的对象内容进行修改并加入 B 的引用时。则将这个引用加入到记录集中。 「小回收」的时候，因为记录集中有对 B 的引用，所以 B 不再是垃圾   三色标记算法 三色标记算法是对标记阶段的改进——标记了两次（灰色，黑色），原理如下：</description>
    </item>
    
    <item>
      <title>GMP</title>
      <link>https://TomatoAres.github.io/posts/gmp/</link>
      <pubDate>Mon, 02 Sep 2019 11:02:52 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/gmp/</guid>
      <description></description>
    </item>
    
    <item>
      <title>go test 工具的简单介绍和使用</title>
      <link>https://TomatoAres.github.io/posts/go-test/</link>
      <pubDate>Thu, 29 Aug 2019 01:44:15 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/go-test/</guid>
      <description>简单介绍 go test 子命令是 Go 语言包的测试驱动程序，在一个包目录中，以*_test.go命名方式的文件，是go test编译的目标（不是go build）
在*_test.go 文件中，三种函数需要特殊对待，即功能测试函数、基准测试函数和示例函数：
 功能测试函数：以Test前缀命名的函数，用来检测一些程序逻辑的正确性 基准测试函数：以Benchmark开头，用来测试某些操作的性能 示例函数：以Example开头，用来提供机器检查过的文档 参考代码1 参考代码2  简单使用 Test函数 首先，在某一工程目录下创建两个文件：test.go(即源码文件)和test_test.go(即单元测试文件)，因为go test 命令只能在一个相应的目录下执行所有文件
test.go源码文件，创建一个test包，并实现一个除法运算 package test import ( &amp;quot;errors&amp;quot; ) func Division(a, b float64) (float64, error) { if b == 0 { return 0, errors.New(&amp;quot;除数不能为0&amp;quot;) } return a / b, nil }  test_test.go 测试单元文件  注意事项：
 文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码 你必须import testing这个包 测试用例会按照源代码中写的顺序依次执行 测试格式：func TestXxx (t *testing.T),Xxx部分可以为任意的字母数字的组合，但是首字母一定为大写字母 函数中通过调用testing.T的一些方法来说明测试通过或不通过： 调用t.Error()或t.Errorf()方法记录日志并标记测试失败,测试函数中的某条测试用例执行结果与预期不符时使用 Log和Logf方法用于日志输出，默认只输出错误日志，如果要输出全部日志需要使用-v Fail标记用例失败，但继续执行当前用例。FailNow标记用例失败并且立即停止执行当前用例，继续执行下一个（默认按书写顺序）用例 Error等价于Log加Fail，Errorf等价于Logf加Fail 使用t.</description>
    </item>
    
    <item>
      <title>channel 总结</title>
      <link>https://TomatoAres.github.io/posts/channel/</link>
      <pubDate>Wed, 21 Aug 2019 16:57:56 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/channel/</guid>
      <description>1. 声明和类型 ChannelType = ( &amp;quot;chan&amp;quot; | &amp;quot;chan&amp;quot; &amp;quot;&amp;lt;-&amp;quot; | &amp;quot;&amp;lt;-&amp;quot; &amp;quot;chan&amp;quot; ) ElementType . 声明 双向：var ReadAndWriteChannel chan int 仅可读：var OnlyReadChannel &amp;lt;- chan int 仅可写：var OnlyWriteChannel chan &amp;lt;- int  初始化： make(chan int) //坑：没有数据，读取阻塞，直至写入数据 make(chan int,100) // 容量 缓存 buffer  2. 操作 c := make(chan int) 读:i := &amp;lt;- c 写: c &amp;lt;- (7+2) 遍历: range c 关闭: close(c) 坑：关闭channel，可读，不可写（panic） 多值接收：判断是否关闭 x,ok := &amp;lt;-c //（ok == false 关闭）  阻塞情况一览 这些阻塞可能引起 deadlock——阻塞致死</description>
    </item>
    
    <item>
      <title>Echo 的简单使用</title>
      <link>https://TomatoAres.github.io/posts/echo/</link>
      <pubDate>Fri, 16 Aug 2019 16:57:56 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/echo/</guid>
      <description>echo框架的简单使用 本文是工作刚接触 go 语言，需要作分享时做的一份总结，重新整理的结果。
源码
特性概述 总的来说：轻量·高效
 优化的HTTP路由器，巧妙地确定路由优先级
 构建健壮且可伸缩的RESTful API
 组API
 可扩展的中间件框架
 以根，组或路径级别定义中间件
 JSON，XML和表单的数据绑定
 便捷地发送各种HTTP响应
 集中的HTTP错误处理
 可以使用任何模板引擎
 自定义logger
 高度可定制
 从 Let’s Encrypt（第三方网站）自动加载TLS
 HTTP / 2支持
  简单例子：helloworld package main import ( &amp;quot;net/http&amp;quot; &amp;quot;github.com/labstack/echo&amp;quot; &amp;quot;github.com/labstack/echo/middleware&amp;quot; ) func main() { //创建echo对象 e := echo.New() //中间件 e.Use(middleware.Logger()) e.Use(middleware.Recover()) //路由route 映射 handler（函数） e.GET(&amp;quot;/&amp;quot;, func(c echo.Context) error { return c.String(http.StatusOK, &amp;quot;Hello, World!</description>
    </item>
    
    <item>
      <title>为什么 Go 适合微服务</title>
      <link>https://TomatoAres.github.io/posts/why-go-is-good-language-for-microservices/</link>
      <pubDate>Wed, 14 Aug 2019 23:10:09 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/why-go-is-good-language-for-microservices/</guid>
      <description>去年早些时候，我们决定改用 Go(Golang) 作为我们（SafetyCulture）开发微服务的选择。在这之前，我们的微服务使用 Node.js(CoffeeScript, Javascript 和 TypeScript 的混合) 编写。下来我将分享我们更改的原因。
1.静态类型 Go 是一种静态类型语言，这意味着编译器可以为您做更多的工作。人们倾向于强调这一点的重要性。
生产事故的故事 去年，在为我们的一个核心微服务修复 bug 时，我造成了一个生产事故（用 Node 编写），因为我在函数中添加了一个额外的参数，忘记在调用函数时传递正确的参数。
// 函数定义 function saveDocument({id, oldDocument, newDocument}) {} // 函数调用 saveDocument({ id: &amp;quot;xyz&amp;quot;, oldDoc: &amp;quot;blah blah&amp;quot;, newDocument: &amp;quot;new doc&amp;quot; })  我的函数期望传入 oldDocument 类型的参数，但是我传了 oldDoc 类型。最终， oldDocument 应该需要写入 Kafaka, 以供下游其他微服务使用。所有测试都通过了，我将其作为产品发布，仅发布 3 天，我们就意识到问题。这个问题花费了我们两个全职工程师工作了整整 3 天才修复。
当然，您可以使用 TypeScript 并解决这个问题（希望如此），但为什么不选择一种语言来帮助您在编译时捕获问题？在当今的世界，团队们正在开发 20 种不同的微服务，你需要记忆大量内容，编译过程提供一些帮助是有好处的。我在生产 ROR 应用程序之前也看到了类似的问题，我可以将 string 类型更改为 int, 数组，甚至任意类型都没有类型，直到出现问题或者伤害了你的用户。Airbnb 表示，使用类型可以预防 38％ 的漏洞。
2.可读性 清晰好过聪明（Clear is better than clever）</description>
    </item>
    
    <item>
      <title>Go 语言中的微服务</title>
      <link>https://TomatoAres.github.io/posts/microservices-in-go/</link>
      <pubDate>Wed, 14 Aug 2019 23:04:12 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/microservices-in-go/</guid>
      <description>摘要 我最近在墨尔本 Golang 聚会上就如何开发微服务和框架做了一次演讲。在本文中，我将与您分享我的想法（此外，它对我来说是一个很好的复习）。
在这里，我要介绍以下框架：
 Go Micro Go Kit Gizmo Kite  框架简介 Go Micro 这是我认为最受欢迎的框架之一。有很多博客文章和简单的例子可供使用参考。您可以从 microhq 在 Medium 或 @MicroHQ 获得 Go Micro 的最新更新。
那么，什么是 Go Micro ?
它是一个可拔插的 RPC 框架，用于在 Go 中编写微服务。开箱即用，您将看到：
 服务发现 - 自动向服务发现系统注册的应用程序。 负载均衡 - 客户端负载均衡，用于平衡服务实例之间请求的负载。 同步通信 - 提供请求/响应传输层。 异步通信 - 内置发布/订阅功能。 消息编码 - 基于消息的 Content-Type 请求头的编码/解码。 RPC 客户端/服务器打包 - 利用上述特性并公开接口来构建微服务。  Go Micro 架构可以描述为三层堆栈。
顶层包括 Server-Client 模型和服务抽象。该服务器是用于编写服务的基础。而客户端提供了一个接口，用于向服务端发起请求。
底层包含以下类型的插件：
 Broker - 提供一个消息代理接口，用于异步发布/订阅通信。 Codec - 用于编码/解码消息。支持的格式包括 json,bson,protobuf,msgpack 等。 Registry - 提供服务发现机制（默认为 Consul ）。 Selector - 基于注册表构建的负载均衡抽象。 它允许使用诸如 random,roundrobin,leastconn 等算法“选择”服务。 Transport - 服务之间同步请求/响应通信的接口。  Go Micro 还提供 Sidecar 等功能。这允许您使用Go以外的语言编写的服务。 Sidecar 提供服务注册，gRPC 编码/解码和HTTP处理程序。它有多种语言版本。</description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>西红柿的博客</title>
    <link>https://TomatoAres.github.io/</link>
    <description>Recent content on 西红柿的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved - TomatoAres 2019</copyright>
    <lastBuildDate>Tue, 03 Sep 2019 14:29:20 +0800</lastBuildDate>
    
	<atom:link href="https://TomatoAres.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>行数据库 vs 列数据库</title>
      <link>https://TomatoAres.github.io/posts/%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93-vs-%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Tue, 03 Sep 2019 14:29:20 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93-vs-%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>是什么  列式数据库是以列相关存储架构进行数据存储的数据库，主要适合于批量数据处理和即时查询。 行式数据库，数据以行相关的存储体系架构进行空间分配，主要适合于小批量的数据处理，常用于联机事务型数据处理。  举例 数据库以行、列的二维表的形式存储数据，但是却以一维字符串的方式存储，例如以下的一个表：
   EmpId Lastname Firstname Salary     1 Smith Joe 40000   2 Jones Mary 50000   3 Johnson Cathy 44000    这个简单的表包括员工代码(EmpId), 姓名字段(Lastname and Firstname)及工资(Salary).
这个表存储在电脑的内存(RAM)和存储(硬盘)中。虽然内存和硬盘在机制上不同，电脑的操作系统是以同样的方式存储的。数据库必须把这个二维表存储在一系列一维的“字节”中，由操作系统写到内存或硬盘中。
行式数据库把一行中的数据值串在一起存储起来，然后再存储下一行的数据，以此类推。
1,Smith,Joe,40000; 2,Jones,Mary,50000; 3,Johnson,Cathy,44000;  列式数据库把一列中的数据值串在一起存储起来，然后再存储下一列的数据，以此类推。
1,2,3; Smith,Jones,Johnson; Joe,Mary,Cathy; 40000,50000,44000;  优势：
 由于设计上的不同，列式数据库在并行查询处理和压缩上更有优势。 而且数据是以列为单元存储，完全不用考虑数据建模或者说建模更简单了。要查询计算哪些列上的数据，直接读取列就行了。 不像行式数据库，一行上有多列，尽管我们只需要分析某些列的数据，也要读取表上的全部数据。比如说这句 sql：&amp;rdquo;select a, b from table limit 100&amp;rdquo;， 列式数据库只需要读取 a，b 这两列前 100 行到内存中，而行式数据库则需要将前 100 行数据都读入内存中。显而易见，列式数据库的 IO 更高效。  应用:</description>
    </item>
    
    <item>
      <title>Radix Tree 基数树</title>
      <link>https://TomatoAres.github.io/posts/radix-tree-%E5%9F%BA%E6%95%B0%E6%A0%91/</link>
      <pubDate>Mon, 02 Sep 2019 23:10:56 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/radix-tree-%E5%9F%BA%E6%95%B0%E6%A0%91/</guid>
      <description>参考： 数据结构之 Radix Tree https://blog.csdn.net/joker0910/article/details/8250085
定义 在计算机科学中，radix tree (也被称为 radix trie，或者 compact prefix tree)用于表示一种空间优化的 trie(prefix tree) 数据结构。
假如树中的一个节点是父节点的唯一子节点(the only child)的话，那么该子节点将会与父节点进行合并，这样就使得 radix tree 中的每一个内部节点最多拥有 r 个孩子， r 为正整数且等于 2^n(n&amp;gt;=1)。
不像是一般的 trie 树，radix tree 的边沿(edges)可以是一个或者多个元素。参看如下：
使用场景 元素个数不是太多，但是元素之间通常有很长的相同前缀时很适合采用 radix tree 来存储</description>
    </item>
    
    <item>
      <title>Go 中 Byte Rune</title>
      <link>https://TomatoAres.github.io/posts/byte-rune/</link>
      <pubDate>Mon, 02 Sep 2019 23:03:44 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/byte-rune/</guid>
      <description>byte 实质上就是 uint8 类型。byte 用来强调数据是 raw data，而不是数字； rune 实质上就是 int32 类型。而 rune 用来表示 Unicode 的 code point。
uint8 the set of all unsigned 8-bit integers (0 to 255) int32 the set of all signed 32-bit integers (-2147483648 to 2147483647) byte alias for uint8 rune alias for int32  // byte is an alias for uint8 and is equivalent to uint8 in all ways. It is // used, by convention, to distinguish byte values from 8-bit unsigned // integer values.</description>
    </item>
    
    <item>
      <title>Csrf Xss 总结</title>
      <link>https://TomatoAres.github.io/posts/csrf-xss/</link>
      <pubDate>Mon, 02 Sep 2019 21:49:35 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/csrf-xss/</guid>
      <description>CSRF 是什么 CSRF（Cross-site request forgery）：跨站请求伪造。
CSRF 的攻击原理 用户是网站 A 的注册用户，且登录进去，于是网站 A 就给用户下发 cookie。 从上图可以看出，要完成一次 CSRF 攻击，受害者必须满足两个必要的条件： （1）登录受信任网站 A，并在本地生成 Cookie。（如果用户没有登录网站 A，那么网站 B 在诱导的时候，请求网站 A 的 api 接口时，会提示你登录） （2）在不登出 A 的情况下，访问危险网站 B（其实是利用了网站 A 的漏洞）。
我们在讲 CSRF 时，一定要把上面的两点说清楚。 温馨提示一下，cookie 保证了用户可以处于登录状态，但网站 B 其实拿不到 cookie。
举个例子，前端事假你，微博网站有个 api 接口有漏洞，导致很多用户的粉丝暴增。
CSRF 如何防御 方法一、Token 验证：（用的最多） （1）服务器发送给客户端一个 token； （2）客户端提交的表单中带着这个 token。 （3）如果这个 token 不合法，那么服务器拒绝这个请求。
方法二：隐藏令牌 把 token 隐藏在 http 的 head 头中。 方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。
方法三、Referer 验证 Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。
XSS（Cross Site Scripting）：跨域脚本攻击 核心是 注入 恶意代码</description>
    </item>
    
    <item>
      <title>Http 方法总结</title>
      <link>https://TomatoAres.github.io/posts/http-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 02 Sep 2019 21:16:34 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/http-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>一、GET GET 方法通常用于获取资源。在 GET 请求中一般不会包含呈现数据（如 HTML 文本、图片、视频等）。
使用中发现：
 postman 和浏览器均无法携带 请求体 es 查询可以  二、HEAD 获取报文的首部。和 GET 方法是一样的，但是他不反悔报文实体的主体部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。
三、POST 一般用于传输实体主体，主要用来传输数据。
GET 和 POST 的区别
 作用: GET 主要用来获取资源、POST 主要用来传输实体主体（数据）。 参数:GET 和 POST 的请求都能使用额外参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在请求体中。
/**GET方式**/ GET /test/demo_form.asp?name1=value1&amp;amp;name2=value2 HTTP/1.1 /**POST方式**/ POST /test/demo_form.asp HTTP/1.1 Host: w3schools.com name1=value1&amp;amp;name2=value2   注意：
 但是不能因为 POST 参数存储在实体主体中就认为它的安全性高，因为照样可以通过一些抓包工具（如：Fiddler）查看。 因为 URL 只支持 ASCII 码，因此 GET 中的参数如果存在中文等字符就需要先进行编码，在服务器进行解码。POST 请求支持标准字符集。  四、PUT 一般用于上传文件，由于 PUT 方法本身不带验证机制，任何人都可以上传文件，因此存在安全问题，一般我们不使用此方法。</description>
    </item>
    
    <item>
      <title>Go 逃逸分析</title>
      <link>https://TomatoAres.github.io/posts/go-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 02 Sep 2019 21:07:29 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/go-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</guid>
      <description> 参考：Go 逃逸分析
堆和栈 要理解什么是逃逸分析会涉及堆和栈的一些基本知识，如果忘记的同学我们可以简单的回顾一下：
 堆（Heap）：一般来讲是人为手动进行管理，手动申请、分配、释放。 堆适合不可预知大小的内存分配，这也意味着为此付出的代价是分配速度较慢，而且会形成内存碎片。 栈（Stack）：由编译器进行管理，自动申请、分配、释放。 一般不会太大，因此栈的分配和回收速度非常快；我们常见的函数参数（不同平台允许存放的数量不同），局部变量等都会存放在栈上。 栈分配内存只需要两个 CPU 指令：“PUSH”和“RELEASE”，分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。  通俗比喻的说，
 栈就如我们去饭馆吃饭，只需要点菜（发出申请）&amp;ndash;》吃吃吃（使用内存）&amp;ndash;》吃饱就跑剩下的交给饭馆（操作系统自动回收）， 而堆就如在家里做饭，大到家，小到买什么菜，每一个环节都需要自己来实现，但是自由度会大很多。 在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针  逃逸分析 再往简单的说，Go 是通过在编译器里做逃逸分析（escape analysis）来决定一个对象放栈上还是放堆上，不逃逸的对象放栈上，可能逃逸的放堆上；即我发现变量在退出函数后没有用了，那么就把丢到栈上，毕竟栈上的内存分配和回收比堆上快很多；反之，函数内的普通变量经过逃逸分析后，发现在函数退出后变量还有在其他地方上引用，那就将变量分配在堆上。做到按需分配（哪里的人民需要我，我就往哪去~~，一个党员的呐喊）。
为何需要逃逸分析 ok，了解完堆和栈各自的优缺点后，我们就可以更好的知道逃逸分析存在的目的了：
 减少 gc 压力，栈上的变量，随着函数退出后系统直接回收，不需要 gc 标记后再清除。 减少内存碎片的产生。 减轻分配堆内存的开销，提高程序的运行速度。  如何确定是否逃逸 在 Go 中通过逃逸分析日志来确定变量是否逃逸，开启逃逸分析日志：
go run -gcflags &#39;-m -l&#39; main.go   -m 会打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 -m，但是信息量较大，一般用 1 个就可以了。 -l 会禁用函数内联，在这里禁用掉内联能更好的观察逃逸情况，减少干扰。  </description>
    </item>
    
    <item>
      <title>Go GC </title>
      <link>https://TomatoAres.github.io/posts/gc-go/</link>
      <pubDate>Mon, 02 Sep 2019 19:39:18 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/gc-go/</guid>
      <description>参考：GO GC 垃圾回收机制
Go 作为一门高级语言，具有 自动垃圾回收 的功能。
常见垃圾回收机制 1. 引用计数：引用计数通过在对象上增加自己被引用的次数，被其他对象引用时加 1，引用自己的对象被回收时减 1，引用数为 0 的对象即为可以被回收的对象 优点： 1. 方式简单，回收速度快。
缺点： 1. 需要额外的空间存放计数。 2.无法处理循环引用（如 a.b=b;b.a=a 这种情况）。 3.频繁更新引用计数降低了性能。
2. 标记-清除（mark and sweep）：对引用对象进行标记，清除未引用对象（需要两次扫描） 步骤：
 标记从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”； 标记完成后进行清除操作，对没有标记过——即没有引用过的内存进行回收（回收同时可能伴有碎片整理操作）。  优点： 解决了引用计数的缺点 1 节约了内存，2 解决了循环引用的问题
缺点： 每次启动垃圾回收都会暂停当前所有的正常代码执行，回收是系统响应能力大大降低！
优化方式： mark&amp;amp;sweep 算法的变种（如三色标记法）
3. 复制收集：新空间复制引用的对象，清除旧空间 过程： 准备一个「新的空间」，从根开始，对对象进行扫，如果存在对这个对象的引用，就把它复制到「新空间中」。一次扫描结束之后，所有存在于「新空间」的对象就是所有的非垃圾对象。
优点： 只需要对对象进行一次扫描。
4. 分代收集（generation）：根据存活时间 分代——新生代和老年代 默认 大部分对象的声明周期很短——新生代为主，小回收垃圾少
关键过程：
 新创建的对象存放在称为 新生代（young generation）中 ——一般来说，新生代的大小会比 老年代小很多。 高频对新生成的对象进行回收，称为「小回收」，低频对所有对象回收，称为「大回收」。 每一次「小回收」过后，就把存活下来的对象归为老年代，「小回收」的时候，遇到老年代直接跳过。大多数分代回收算法都采用的「复制收集」方法，因为小回收中垃圾的比例较大。  新问题： 老年代对新生代引用，还能进行小回收吗？
解决：这里用到了一中叫做写屏障的方式。
 程序对所有涉及修改对象内容的地方进行保护，被称为「写屏障」（Write Barrier）。写屏障不仅用于分代收集，也用于其他 GC 算法中。 在此算法的表现是  用一个记录集来记录从新生代到老生代的引用。 如果有两个对象 A （老生代） 和 B（新生代），当对 A 的对象内容进行修改并加入 B 的引用时。则将这个引用加入到记录集中。 「小回收」的时候，因为记录集中有对 B 的引用，所以 B 不再是垃圾   三色标记算法 三色标记算法是对标记阶段的改进——标记了两次（灰色，黑色），原理如下：</description>
    </item>
    
    <item>
      <title>GMP</title>
      <link>https://TomatoAres.github.io/posts/gmp/</link>
      <pubDate>Mon, 02 Sep 2019 11:02:52 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/gmp/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Mysql 面试题总结</title>
      <link>https://TomatoAres.github.io/posts/mysql-%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 01 Sep 2019 19:52:00 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/mysql-%E6%80%BB%E7%BB%93/</guid>
      <description>主键 超键 候选键 外键  主 键： 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。 超 键： 在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 候选键： 是最小超键，即没有冗余元素的超键。 外 键： 在一个表中存在的另一个表的主键称此表的外键。  事务 transanction MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！
 在 MySQL 中只有使用了 *Innodb 数据库引擎*的数据库或表才支持事务。 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。 事务用来管理 insert,update,delete 语句  缩写常用：ACID
 Atomicity 原子性:  整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。 事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。  Consistency 一致性：  类似线程安全：并行，并发执行结果和顺序执行一致  Isolation 隔离性：  不受其他行为干扰：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。 事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。  Duration 持久性：  事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。   视图 view 视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。
作用： 使用视图可以简化复杂的 sql 操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。</description>
    </item>
    
    <item>
      <title>HTTP 2.0</title>
      <link>https://TomatoAres.github.io/posts/http-2.0/</link>
      <pubDate>Sat, 31 Aug 2019 17:55:36 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/http-2.0/</guid>
      <description>HTTP/2 (原本的名字是 HTTP/2.0) 是万维网使用的 HTTP 网络协议的第二个主要版本。HTTP/2 提供了更快的速度和更好的用户体验。
特性  使用二进制格式传输数据，而不是文本。使得在解析和优化扩展上更为方便。 多路复用，所有的请求都是通过一个 TCP 连接并发完成。 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量。 Server Push：服务端能够更快的把资源推送给客户端。  参考：让面试官颤抖的 HTTP 2.0 协议面试题</description>
    </item>
    
    <item>
      <title>Websocket 总结</title>
      <link>https://TomatoAres.github.io/posts/websocket%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 31 Aug 2019 16:36:01 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/websocket%E6%80%BB%E7%BB%93/</guid>
      <description> 是什么  WebSocket 是通过单个 TCP 连接提供全双工（双向通信）通信信道的计算机通信协议。 在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。——长链接，直到关闭  过程  客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息 &amp;ldquo;Upgrade: WebSocket&amp;rdquo; 表明这是一个申请协议升级的 HTTP 请求 服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了 双方就可以通过这个连接通道自由的传递信息 持续存在直到客户端或者服务器端的某一方主动的关闭连接。  </description>
    </item>
    
    <item>
      <title>Restful 总结</title>
      <link>https://TomatoAres.github.io/posts/restful%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 31 Aug 2019 16:24:33 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/restful%E6%80%BB%E7%BB%93/</guid>
      <description>是什么  基于 HTTP 开发 web 服务 一种规范,说是一种风格可能更合适——可遵守，可不遵守 资源 和 uri 绑定 增删改查对应 HTTP 的四种方法 —— GET,POST,PUT,DELETE  好处  规范化设计 可读性  使用 接口命名规则：http://IP:端口/app-name/rest/v/接口名（资源名）/param
工作中遇到的问题 批量删除 用的 post 解决的，携带数组，或者在查询参赛携带 delete=all</description>
    </item>
    
    <item>
      <title>Hugo 静态文件使用</title>
      <link>https://TomatoAres.github.io/posts/hugo-%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Thu, 29 Aug 2019 02:05:47 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/hugo-%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/</guid>
      <description>放入 static 文件夹下
例如： 图片放入 image 下 network 文件下
！[说明文字](/image/network/文件名)  </description>
    </item>
    
    <item>
      <title>Hugo github.io 无样式问题</title>
      <link>https://TomatoAres.github.io/posts/hugo-%E6%A0%B7%E5%BC%8F/</link>
      <pubDate>Thu, 29 Aug 2019 01:53:01 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/hugo-%E6%A0%B7%E5%BC%8F/</guid>
      <description>hugo 建站后，生成静态页面并上传 github 仓库，无法正常显示主题样式
hugo --theme=ananke --baseUrl=&amp;quot;http://TomatoAres.github.io/&amp;quot;  将上述命令中的 http 改为 https 即可解决
hugo --theme=ananke --baseUrl=&amp;quot;https://TomatoAres.github.io/&amp;quot;  参考：使用 Hugo 搭建个人博客</description>
    </item>
    
    <item>
      <title>go test 工具的简单介绍和使用</title>
      <link>https://TomatoAres.github.io/posts/go-test/</link>
      <pubDate>Thu, 29 Aug 2019 01:44:15 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/go-test/</guid>
      <description>简单介绍 go test 子命令是 Go 语言包的测试驱动程序，在一个包目录中，以*_test.go命名方式的文件，是go test编译的目标（不是go build）
在*_test.go 文件中，三种函数需要特殊对待，即功能测试函数、基准测试函数和示例函数：
 功能测试函数：以Test前缀命名的函数，用来检测一些程序逻辑的正确性 基准测试函数：以Benchmark开头，用来测试某些操作的性能 示例函数：以Example开头，用来提供机器检查过的文档 参考代码1 参考代码2  简单使用 Test函数 首先，在某一工程目录下创建两个文件：test.go(即源码文件)和test_test.go(即单元测试文件)，因为go test 命令只能在一个相应的目录下执行所有文件
test.go源码文件，创建一个test包，并实现一个除法运算 package test import ( &amp;quot;errors&amp;quot; ) func Division(a, b float64) (float64, error) { if b == 0 { return 0, errors.New(&amp;quot;除数不能为0&amp;quot;) } return a / b, nil }  test_test.go 测试单元文件  注意事项：
 文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码 你必须import testing这个包 测试用例会按照源代码中写的顺序依次执行 测试格式：func TestXxx (t *testing.T),Xxx部分可以为任意的字母数字的组合，但是首字母一定为大写字母 函数中通过调用testing.T的一些方法来说明测试通过或不通过： 调用t.Error()或t.Errorf()方法记录日志并标记测试失败,测试函数中的某条测试用例执行结果与预期不符时使用 Log和Logf方法用于日志输出，默认只输出错误日志，如果要输出全部日志需要使用-v Fail标记用例失败，但继续执行当前用例。FailNow标记用例失败并且立即停止执行当前用例，继续执行下一个（默认按书写顺序）用例 Error等价于Log加Fail，Errorf等价于Logf加Fail 使用t.</description>
    </item>
    
    <item>
      <title>性能测试中 allocs/op 和 B/op 的含义</title>
      <link>https://TomatoAres.github.io/posts/benchmark/</link>
      <pubDate>Thu, 29 Aug 2019 01:42:13 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/benchmark/</guid>
      <description> allocs/op 表示每个 op 发生多少个不同的内存分配（单次迭代）。越小越好 B/op 是每个操作分配了多少字节。 越小越好  </description>
    </item>
    
    <item>
      <title>TCP 总结</title>
      <link>https://TomatoAres.github.io/posts/tcp-%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 29 Aug 2019 00:52:58 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/tcp-%E6%80%BB%E7%BB%93/</guid>
      <description>通信过程 服务端：
 socket：建立 socket bind：绑定服务端 ip listen：开始监听 accept：等待连接（阻塞） read/write：通信 close：关闭连接  三次握手——建立通信过程 参考：TCP 的三次握手与四次挥手（详解+动图）
涉及到状态：
 closed SYN_SENT SYN_RECV ESTABLISHED  四次挥手——断开连接 涉及到状态：
 ESTABLISHED FIN_WAIT1 FIN_WAIT2  问题总结  tcp 的 2MSL 问题
MSL：Maximum Segment Lifetime，最长报文时间
2MSL 即两倍的 MSL ，TCP 的 TIME_WAIT 状态也称为 2MSL 等待状态，
当 TCP 的一端发起主动关闭，在发出最后一个 ACK 包后，
即第 3 次握手完成后发送了第四次握手的 ACK 包后就进入了 TIME_WAIT 状态，
必须在此状态上停留两倍的 MSL 时间，
等待 2MSL 时间主要目的是怕最后一个 ACK 包对方没收到，
那么对方在超时后将重发第三次握手的 FIN 包，</description>
    </item>
    
    <item>
      <title>进程线程协程总结</title>
      <link>https://TomatoAres.github.io/posts/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Thu, 22 Aug 2019 11:55:05 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</guid>
      <description>通俗易懂的例子 参考:每个程序员都会遇到的面试问题：谈谈进程和线程的区别
1.计算机的核心是 CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。
2.假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个 CPU 一次只能运行一个任务。
3.进程就好比工厂的车间，它代表 CPU 所能处理的单个任务。任一时刻，CPU 总是运行一个进程，其他进程处于非运行状态。
4.一个车间里，可以有很多工人。他们协同完成一个任务。
5.线程就好比车间里的工人。一个进程可以包括多个线程。
6.车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。
7.可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。
8.一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫&amp;rdquo;互斥锁&amp;rdquo;（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。
9.还有些房间，可以同时容纳 n 个人，比如厨房。也就是说，如果人数大于 n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。
10.这时的解决方法，就是在门口挂 n 把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做&amp;rdquo;信号量&amp;rdquo;（Semaphore），用来保证多个线程不会互相冲突。
进程  强调一个运行的状态：编写完毕的代码，在没有运行的时候，称之为程序。正在运行着的代码，就成为进程— 操作系统分配的一个基本单位：运行一个程序，就创作一个进程，操作系统分配资源。 隔离和共享： 进程内部共享资源，进程间不能直接共享资源  线程  线程是 CPU 调度和分派的基本单位：是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。如果把进程理解为在逻辑上操作系统所完成的任务，那么线程表示完成该任务的许多可能的子任务之一。 它可与同属一个进程的其他的线程共享进程所拥有的全部资源， 常常多个线程共享资源时要加互斥锁，避免数据竞争状态的出现  进程线程对比 参考：进程与线程，单核与多核
联系：
 一个线程只能属于一个进程，而一个进程可以有多个线程，至少有一个线程。 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 处理机分给线程，即真正在处理机上运行的是线程。 线程在执行过程中，需要协作同步（加锁，通道）。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体.  区别：
 资源单位 1 ：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 资源 ：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源. 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。  不同 线程和进程对比
1) 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间 2) 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源 3) 线程是处理器调度的基本单位,但进程不是 4) 二者均可并发执行 5) 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序（进程）中， 由应用程序提供多个线程执行控制</description>
    </item>
    
    <item>
      <title>Docker简介</title>
      <link>https://TomatoAres.github.io/posts/docker%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 22 Aug 2019 11:18:04 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/docker%E7%AE%80%E4%BB%8B/</guid>
      <description>是什么？  容器引擎——核心 开源 go编写 基于LXC(Linux Container)内核虚拟化实现  能干什么？  持续集成  简化配置 代码流水线管理 快速部署 提高开发效率  版本控制 可移植性 —— 可以移动到任意一台Docker主机上 标准性—— 容器保证所有配置依赖不变 隔离性与安全  和虚拟机比的优势  轻量 M G —— 资源都是钱 性能高  共享主机内核， 没有Hypervisor 层开销
 系统级虚拟化， 占用资源少  使用更加方便  配置简单——标准化 要求低，不需要CPU虚拟化技术支持   虚拟机也有优势  安全性好——docker只是进程级别的隔离，虚拟机是物理层面的隔离 有自己完整的操作系统  涉及到的技术  LXC: Linux容器技术，共享内核 Cgroups ：control groups  内核提供的限制资源的技术（CPU，内存）  namespace：隔离技术：  UTS—— 每个容器可以有自己的 hostname 和 domainame IPC——进程间通信 每个容器有其自己的 System V IPC 和 POSIX 消息队列文件系统，因此，只有在同一个 IPC namespace 的进程之间才能互相通信 PID——进程 每个 PID namespace 中的进程可以有其独立的 PID Network、每个容器用有其独立的网络设备，IP 地址，IP 路由表， Mount——每个容器能看到不同的文件系统层次结构 User 每个 container 可以有不同的 user 和 group id  AUFS（advanced multi layered unification filesystem）：高级多层统一文件系统，是UFS的一种  docker engine 关键词：洋葱模型，cs架构</description>
    </item>
    
    <item>
      <title>channel 总结</title>
      <link>https://TomatoAres.github.io/posts/channel/</link>
      <pubDate>Wed, 21 Aug 2019 16:57:56 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/channel/</guid>
      <description>1. 声明和类型 ChannelType = ( &amp;quot;chan&amp;quot; | &amp;quot;chan&amp;quot; &amp;quot;&amp;lt;-&amp;quot; | &amp;quot;&amp;lt;-&amp;quot; &amp;quot;chan&amp;quot; ) ElementType . 声明 双向：var ReadAndWriteChannel chan int 仅可读：var OnlyReadChannel &amp;lt;- chan int 仅可写：var OnlyWriteChannel chan &amp;lt;- int  初始化： make(chan int) //坑：没有数据，读取阻塞，直至写入数据 make(chan int,100) // 容量 缓存 buffer  2. 操作 c := make(chan int) 读:i := &amp;lt;- c 写: c &amp;lt;- (7+2) 遍历: range c 关闭: close(c) 坑：关闭channel，可读，不可写（panic） 多值接收：判断是否关闭 x,ok := &amp;lt;-c //（ok == false 关闭）  阻塞情况一览 这些阻塞可能引起 deadlock——阻塞致死</description>
    </item>
    
    <item>
      <title>TCP UDP 总结</title>
      <link>https://TomatoAres.github.io/posts/tcp-udp/</link>
      <pubDate>Sun, 18 Aug 2019 23:30:07 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/tcp-udp/</guid>
      <description> UDP 用户数据报协议，是一个无连接的简单的面向数据报的运输层协议。 UDP 不提供可靠性，它只是把应用程序传给 IP 层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。
UDP 特点  无连接：UDP 是面向无连接的通讯协议，UDP 数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。 大小限制：UDP 传输数据时有大小限制，每个被传输的数据报必须限定在 64KB 之内。 不可靠： UDP 是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。  应用：注重速度流畅的业务 UDP是面向消息的协议，通信时不需要建立连接，数据的传输自然是不可靠的，UDP一般用于多点通信和实时的数据业务，比如
语音广播 视频 QQ TFTP(简单文件传送） SNMP（简单网络管理协议） RIP（路由信息协议，如报告股票市场，航空信息） DNS(域名解释）  UDP 构建步骤 客户端
 Socket 创建客户端套接字 sendto/recvfrom 发送/接收数据 close 关闭套接字  服务端
 Socket bind recvfrom/sendto  TCP TCP 服务器构建  socket创建一个套接字 bind绑定ip和port listen 使套接字变为可以被动链接 accept等待客户端的链接 recv/send接收发送数据  </description>
    </item>
    
    <item>
      <title>Influxdb 简介</title>
      <link>https://TomatoAres.github.io/posts/influxdb%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sun, 18 Aug 2019 23:07:22 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/influxdb%E7%AE%80%E4%BB%8B/</guid>
      <description> 概述  使用 GO 语言开发 开源 时序数据库：适合用于处理和分析资源监控数据这种时序相关数据 SQL-like 语法  三大特性：
 时序性（Time Series）：与时间相关的函数的灵活使用（诸如最大、最小、求和等）； 度量（Metrics）：对实时大量数据进行计算； 事件（Event）：支持任意的事件数据，换句话说，任意事件的数据我们都可以做操作。  其他特性：
 无结构：schemaless(无结构)，可以是任意数量的列； 度量方便：min, max, sum, count, mean, median 一系列函数，方便统计； 支持 http：Native HTTP API, 内置 http 支持，使用 http 读写； 查询语法简单：Powerful Query Language 类似 sql； 管理方便：Built-in Explorer 自带管理工具。  概念 数据库相关名词
 database：数据库； measurement：数据库中的表； points：表里面的一行数据。  特有名词：
Point 由时间戳（time）、数据（field）和标签（tags）组成。
 time：每条数据记录的时间，也是数据库自动生成的主索引； fields：各种记录的值； tags：各种有索引的属性。  </description>
    </item>
    
    <item>
      <title>MaxSumArray</title>
      <link>https://TomatoAres.github.io/posts/maxsumarray/</link>
      <pubDate>Sat, 17 Aug 2019 17:40:19 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/maxsumarray/</guid>
      <description>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和 示例:
Input: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</description>
    </item>
    
    <item>
      <title>Echo 的简单使用</title>
      <link>https://TomatoAres.github.io/posts/echo/</link>
      <pubDate>Fri, 16 Aug 2019 16:57:56 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/echo/</guid>
      <description>echo框架的简单使用 本文是工作刚接触 go 语言，需要作分享时做的一份总结，重新整理的结果。
源码
特性概述 总的来说：轻量·高效
 优化的HTTP路由器，巧妙地确定路由优先级
 构建健壮且可伸缩的RESTful API
 组API
 可扩展的中间件框架
 以根，组或路径级别定义中间件
 JSON，XML和表单的数据绑定
 便捷地发送各种HTTP响应
 集中的HTTP错误处理
 可以使用任何模板引擎
 自定义logger
 高度可定制
 从 Let’s Encrypt（第三方网站）自动加载TLS
 HTTP / 2支持
  简单例子：helloworld package main import ( &amp;quot;net/http&amp;quot; &amp;quot;github.com/labstack/echo&amp;quot; &amp;quot;github.com/labstack/echo/middleware&amp;quot; ) func main() { //创建echo对象 e := echo.New() //中间件 e.Use(middleware.Logger()) e.Use(middleware.Recover()) //路由route 映射 handler（函数） e.GET(&amp;quot;/&amp;quot;, func(c echo.Context) error { return c.String(http.StatusOK, &amp;quot;Hello, World!</description>
    </item>
    
    <item>
      <title>横向·纵向扩展区别</title>
      <link>https://TomatoAres.github.io/posts/horizon-vertical/</link>
      <pubDate>Fri, 16 Aug 2019 16:54:50 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/horizon-vertical/</guid>
      <description>经常看到容器介绍说 便于水平（横向）扩展，想想应该有纵向才对，查找发现下边这个解释真不错
 横向扩展（Horizon） 也叫 水平扩展，用更多的节点支撑更大量的请求。
 如成千上万的蚂蚁完成一项搬运工作  纵向扩展 又叫 垂直扩展，扩展一个点的能力支撑更大的请求。
 如利用 1 个人的能力，如蜘蛛侠逼停火车   </description>
    </item>
    
    <item>
      <title>How to Ask Questions</title>
      <link>https://TomatoAres.github.io/posts/how-to-ask-questions/</link>
      <pubDate>Thu, 15 Aug 2019 17:02:52 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/how-to-ask-questions/</guid>
      <description>提问的智慧 艾瑞克.史蒂文.雷蒙德（Eric Steven Raymond） Thyrsus Enterprises
esr@thyrsus.com
瑞克.莫恩（Rick Moen） respond-auto@linuxmafia.com 版权©2001, 2006 Eric S. Raymond, Rick Moen
修订历史 修订版 3.9	2013年4月23日	esr 修正链接 修订版 3.8	2012年6月19日	esr 修正链接 修订版 3.7	2010年12月6日	esr 对于英语为第二语言人士的有益建议 修订版 3.7	2010年11月2日	esr 几种翻译不见了 修订版 3.6	2008年3月19日	esr 小更新及新链接 修订版 3.5	2008年1月2日	esr 勘误及一些翻译链接 修订版 3.4	2007年3月24日	esr 新章节：“关于代码的问题” 修订版 3.3	2006年9月29日	esr 增加凯.尼格曼（Kai Niggemann）的一个好建议 修订版 3.2	2006年1月10日	esr 加入瑞克.莫恩（Rick Moen）编写的内容 修订版 3.1	2004年10月28日	esr 文档“谷歌是你的朋友！” 修订版 3.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://TomatoAres.github.io/posts/about/</link>
      <pubDate>Wed, 14 Aug 2019 23:22:38 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/about/</guid>
      <description> 简单说明  使用 hugo 建站 存储一些自己的文章  </description>
    </item>
    
    <item>
      <title>Hugo 文章不显示</title>
      <link>https://TomatoAres.github.io/posts/hugo-no-article/</link>
      <pubDate>Wed, 14 Aug 2019 23:10:09 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/hugo-no-article/</guid>
      <description>draft 草稿，若为真，则不现实
所以：
将 draft:true 改为 false 即可
draft:false  </description>
    </item>
    
    <item>
      <title>为什么 Go 适合微服务</title>
      <link>https://TomatoAres.github.io/posts/why-go-is-good-language-for-microservices/</link>
      <pubDate>Wed, 14 Aug 2019 23:10:09 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/why-go-is-good-language-for-microservices/</guid>
      <description>去年早些时候，我们决定改用 Go(Golang) 作为我们（SafetyCulture）开发微服务的选择。在这之前，我们的微服务使用 Node.js(CoffeeScript, Javascript 和 TypeScript 的混合) 编写。下来我将分享我们更改的原因。
1.静态类型 Go 是一种静态类型语言，这意味着编译器可以为您做更多的工作。人们倾向于强调这一点的重要性。
生产事故的故事 去年，在为我们的一个核心微服务修复 bug 时，我造成了一个生产事故（用 Node 编写），因为我在函数中添加了一个额外的参数，忘记在调用函数时传递正确的参数。
// 函数定义 function saveDocument({id, oldDocument, newDocument}) {} // 函数调用 saveDocument({ id: &amp;quot;xyz&amp;quot;, oldDoc: &amp;quot;blah blah&amp;quot;, newDocument: &amp;quot;new doc&amp;quot; })  我的函数期望传入 oldDocument 类型的参数，但是我传了 oldDoc 类型。最终， oldDocument 应该需要写入 Kafaka, 以供下游其他微服务使用。所有测试都通过了，我将其作为产品发布，仅发布 3 天，我们就意识到问题。这个问题花费了我们两个全职工程师工作了整整 3 天才修复。
当然，您可以使用 TypeScript 并解决这个问题（希望如此），但为什么不选择一种语言来帮助您在编译时捕获问题？在当今的世界，团队们正在开发 20 种不同的微服务，你需要记忆大量内容，编译过程提供一些帮助是有好处的。我在生产 ROR 应用程序之前也看到了类似的问题，我可以将 string 类型更改为 int, 数组，甚至任意类型都没有类型，直到出现问题或者伤害了你的用户。Airbnb 表示，使用类型可以预防 38％ 的漏洞。
2.可读性 清晰好过聪明（Clear is better than clever）</description>
    </item>
    
    <item>
      <title>Go 语言中的微服务</title>
      <link>https://TomatoAres.github.io/posts/microservices-in-go/</link>
      <pubDate>Wed, 14 Aug 2019 23:04:12 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/microservices-in-go/</guid>
      <description>摘要 我最近在墨尔本 Golang 聚会上就如何开发微服务和框架做了一次演讲。在本文中，我将与您分享我的想法（此外，它对我来说是一个很好的复习）。
在这里，我要介绍以下框架：
 Go Micro Go Kit Gizmo Kite  框架简介 Go Micro 这是我认为最受欢迎的框架之一。有很多博客文章和简单的例子可供使用参考。您可以从 microhq 在 Medium 或 @MicroHQ 获得 Go Micro 的最新更新。
那么，什么是 Go Micro ?
它是一个可拔插的 RPC 框架，用于在 Go 中编写微服务。开箱即用，您将看到：
 服务发现 - 自动向服务发现系统注册的应用程序。 负载均衡 - 客户端负载均衡，用于平衡服务实例之间请求的负载。 同步通信 - 提供请求/响应传输层。 异步通信 - 内置发布/订阅功能。 消息编码 - 基于消息的 Content-Type 请求头的编码/解码。 RPC 客户端/服务器打包 - 利用上述特性并公开接口来构建微服务。  Go Micro 架构可以描述为三层堆栈。
顶层包括 Server-Client 模型和服务抽象。该服务器是用于编写服务的基础。而客户端提供了一个接口，用于向服务端发起请求。
底层包含以下类型的插件：
 Broker - 提供一个消息代理接口，用于异步发布/订阅通信。 Codec - 用于编码/解码消息。支持的格式包括 json,bson,protobuf,msgpack 等。 Registry - 提供服务发现机制（默认为 Consul ）。 Selector - 基于注册表构建的负载均衡抽象。 它允许使用诸如 random,roundrobin,leastconn 等算法“选择”服务。 Transport - 服务之间同步请求/响应通信的接口。  Go Micro 还提供 Sidecar 等功能。这允许您使用Go以外的语言编写的服务。 Sidecar 提供服务注册，gRPC 编码/解码和HTTP处理程序。它有多种语言版本。</description>
    </item>
    
  </channel>
</rss>
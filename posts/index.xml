<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 西红柿的博客</title>
    <link>https://TomatoAres.github.io/posts/</link>
    <description>Recent content in Posts on 西红柿的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved - TomatoAres 2019</copyright>
    <lastBuildDate>Sun, 18 Aug 2019 23:30:07 +0800</lastBuildDate>
    
	<atom:link href="https://TomatoAres.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>TCP UDP总结</title>
      <link>https://TomatoAres.github.io/posts/tcp-udp/</link>
      <pubDate>Sun, 18 Aug 2019 23:30:07 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/tcp-udp/</guid>
      <description> UDP 用户数据报协议，是一个无连接的简单的面向数据报的运输层协议。 UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。
UDP特点  无连接：UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。 大小限制：UDP传输数据时有大小限制，每个被传输的数据报必须限定在64KB之内。 不可靠： UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。  应用：注重速度流畅的业务 UDP是面向消息的协议，通信时不需要建立连接，数据的传输自然是不可靠的，UDP一般用于多点通信和实时的数据业务，比如
语音广播 视频 QQ TFTP(简单文件传送） SNMP（简单网络管理协议） RIP（路由信息协议，如报告股票市场，航空信息） DNS(域名解释）  UDP构建步骤 客户端
 Socket 创建客户端套接字 sendto/recvfrom 发送/接收数据 close 关闭套接字  服务端
 Socket bind recvfrom/sendto  TCP TCP服务器构建  socket创建一个套接字 bind绑定ip和port listen 使套接字变为可以被动链接 accept等待客户端的链接 recv/send接收发送数据  </description>
    </item>
    
    <item>
      <title>Influxdb简介</title>
      <link>https://TomatoAres.github.io/posts/influxdb%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sun, 18 Aug 2019 23:07:22 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/influxdb%E7%AE%80%E4%BB%8B/</guid>
      <description> Influxdb 概述  使用GO语言开发 开源 时序数据库：适合用于处理和分析资源监控数据这种时序相关数据 SQL-like 语法  三大特性：
 时序性（Time Series）：与时间相关的函数的灵活使用（诸如最大、最小、求和等）； 度量（Metrics）：对实时大量数据进行计算； 事件（Event）：支持任意的事件数据，换句话说，任意事件的数据我们都可以做操作。  其他特性：
 无结构：schemaless(无结构)，可以是任意数量的列； 度量方便：min, max, sum, count, mean, median 一系列函数，方便统计； 支持http：Native HTTP API, 内置http支持，使用http读写； 查询语法简单：Powerful Query Language 类似sql； 管理方便：Built-in Explorer 自带管理工具。  概念 数据库相关名词
 database：数据库； measurement：数据库中的表； points：表里面的一行数据。  特有名词：
Point由时间戳（time）、数据（field）和标签（tags）组成。
 time：每条数据记录的时间，也是数据库自动生成的主索引； fields：各种记录的值； tags：各种有索引的属性。  </description>
    </item>
    
    <item>
      <title>Echo的简单使用</title>
      <link>https://TomatoAres.github.io/posts/echo/</link>
      <pubDate>Fri, 16 Aug 2019 16:57:56 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/echo/</guid>
      <description>echo框架的简单使用 本文是工作刚接触 go 语言，需要作分享时做的一份总结，重新整理的结果。
源码
特性概述 总的来说：轻量·高效
 优化的HTTP路由器，巧妙地确定路由优先级
 构建健壮且可伸缩的RESTful API
 组API
 可扩展的中间件框架
 以根，组或路径级别定义中间件
 JSON，XML和表单的数据绑定
 便捷地发送各种HTTP响应
 集中的HTTP错误处理
 可以使用任何模板引擎
 自定义logger
 高度可定制
 从 Let’s Encrypt（第三方网站）自动加载TLS
 HTTP / 2支持
  简单例子：helloworld package main import ( &amp;quot;net/http&amp;quot; &amp;quot;github.com/labstack/echo&amp;quot; &amp;quot;github.com/labstack/echo/middleware&amp;quot; ) func main() { //创建echo对象 e := echo.New() //中间件 e.Use(middleware.Logger()) e.Use(middleware.Recover()) //路由route 映射 handler（函数） e.GET(&amp;quot;/&amp;quot;, func(c echo.Context) error { return c.String(http.StatusOK, &amp;quot;Hello, World!</description>
    </item>
    
    <item>
      <title>横向·纵向扩展区别</title>
      <link>https://TomatoAres.github.io/posts/horizon-vertical/</link>
      <pubDate>Fri, 16 Aug 2019 16:54:50 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/horizon-vertical/</guid>
      <description> 横向纵向扩展区别 经常看到容器介绍说 便于水平（横向）扩展，想想应该有纵向才对，查找发现下边这个解释真不错
 横向扩展（Horizon） 也叫 水平扩展，用更多的节点支撑更大量的请求。
 如成千上万的蚂蚁完成一项搬运工作  纵向扩展 又叫 垂直扩展，扩展一个点的能力支撑更大的请求。
 如利用1个人的能力，如蜘蛛侠逼停火车   </description>
    </item>
    
    <item>
      <title>How to Ask Questions</title>
      <link>https://TomatoAres.github.io/posts/how-to-ask-questions/</link>
      <pubDate>Thu, 15 Aug 2019 17:02:52 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/how-to-ask-questions/</guid>
      <description>提问的智慧 艾瑞克.史蒂文.雷蒙德（Eric Steven Raymond） Thyrsus Enterprises
esr@thyrsus.com
瑞克.莫恩（Rick Moen） respond-auto@linuxmafia.com 版权©2001, 2006 Eric S. Raymond, Rick Moen
修订历史 修订版 3.9	2013年4月23日	esr 修正链接 修订版 3.8	2012年6月19日	esr 修正链接 修订版 3.7	2010年12月6日	esr 对于英语为第二语言人士的有益建议 修订版 3.7	2010年11月2日	esr 几种翻译不见了 修订版 3.6	2008年3月19日	esr 小更新及新链接 修订版 3.5	2008年1月2日	esr 勘误及一些翻译链接 修订版 3.4	2007年3月24日	esr 新章节：“关于代码的问题” 修订版 3.3	2006年9月29日	esr 增加凯.尼格曼（Kai Niggemann）的一个好建议 修订版 3.2	2006年1月10日	esr 加入瑞克.莫恩（Rick Moen）编写的内容 修订版 3.1	2004年10月28日	esr 文档“谷歌是你的朋友！” 修订版 3.</description>
    </item>
    
    <item>
      <title>Go Test</title>
      <link>https://TomatoAres.github.io/posts/go-test/</link>
      <pubDate>Thu, 15 Aug 2019 01:12:53 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/go-test/</guid>
      <description>go test 工具的简单介绍和使用 简单介绍 go test 子命令是Go语言包的测试驱动程序，在一个包目录中，以*_test.go命名方式的文件，是go test编译的目标（不是go build） 在*_test.go文件中，三种函数需要特殊对待，即功能测试函数、基准测试函数和示例函数：   功能测试函数：以Test前缀命名的函数，用来检测一些程序逻辑的正确性 基准测试函数：以Benchmark开头，用来测试某些操作的性能 示例函数：以Example开头，用来提供机器检查过的文档 参考代码1 参考代码2   简单使用 Test函数 首先，在某一工程目录下创建两个文件：test.go(即源码文件)和test_test.go(即单元测试文件)，因为go test 命令只能在一个相应的目录下执行所有文件  test.go源码文件，创建一个test包，并实现一个除法运算 ```GO package test import ( &amp;quot;errors&amp;quot; ) func Division(a, b float64) (float64, error) { if b == 0 { return 0, errors.New(&amp;quot;除数不能为0&amp;quot;) } return a / b, nil } ```  test_test.go测试单元文件  注意事项：  文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码 你必须import testing这个包 测试用例会按照源代码中写的顺序依次执行 测试格式：func TestXxx (t *testing.</description>
    </item>
    
    <item>
      <title>Benchmark</title>
      <link>https://TomatoAres.github.io/posts/benchmark/</link>
      <pubDate>Thu, 15 Aug 2019 01:09:24 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/benchmark/</guid>
      <description> 性能测试中 allocs/op 和 B/op 的含义  allocs/op 表示每个op发生多少个不同的内存分配（单次迭代）。越小越好 B/op 是每个操作分配了多少字节。 越小越好  </description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://TomatoAres.github.io/posts/about/</link>
      <pubDate>Wed, 14 Aug 2019 23:22:38 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/about/</guid>
      <description> 简单说明  使用 hugo 建站 存储一些自己的文章  </description>
    </item>
    
    <item>
      <title>Hugo 文章不显示</title>
      <link>https://TomatoAres.github.io/posts/no-article/</link>
      <pubDate>Wed, 14 Aug 2019 23:10:09 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/no-article/</guid>
      <description>draft 草稿，若为真，则不现实
所以：
将 draft:true 改为 false即可
draft:false  </description>
    </item>
    
    <item>
      <title>Why Go Is Good Language for Microservices</title>
      <link>https://TomatoAres.github.io/posts/why-go-is-good-language-for-microservices/</link>
      <pubDate>Wed, 14 Aug 2019 23:10:09 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/why-go-is-good-language-for-microservices/</guid>
      <description>为什么 Go 适合微服务 去年早些时候，我们决定改用 Go(Golang) 作为我们（SafetyCulture）开发微服务的选择。在这之前，我们的微服务使用 Node.js(CoffeeScript, Javascript 和 TypeScript 的混合) 编写。下来我将分享我们更改的原因。
1.静态类型 Go是一种静态类型语言，这意味着编译器可以为您做更多的工作。人们倾向于强调这一点的重要性。
生产事故的故事 去年，在为我们的一个核心微服务修复 bug 时，我造成了一个生产事故（用 Node 编写），因为我在函数中添加了一个额外的参数，忘记在调用函数时传递正确的参数。
// 函数定义 function saveDocument({id, oldDocument, newDocument}) {} // 函数调用 saveDocument({ id: &amp;quot;xyz&amp;quot;, oldDoc: &amp;quot;blah blah&amp;quot;, newDocument: &amp;quot;new doc&amp;quot; })  我的函数期望传入 oldDocument 类型的参数，但是我传了 oldDoc 类型。最终， oldDocument 应该需要写入 Kafaka, 以供下游其他微服务使用。所有测试都通过了，我将其作为产品发布，仅发布 3 天，我们就意识到问题。这个问题花费了我们两个全职工程师工作了整整 3 天才修复。
当然，您可以使用 TypeScript 并解决这个问题（希望如此），但为什么不选择一种语言来帮助您在编译时捕获问题？在当今的世界，团队们正在开发20种不同的微服务，你需要记忆大量内容，编译过程提供一些帮助是有好处的。我在生产 ROR 应用程序之前也看到了类似的问题，我可以将 string 类型更改为 int, 数组，甚至任意类型都没有类型，直到出现问题或者伤害了你的用户。Airbnb 表示，使用类型可以预防 38％ 的漏洞。
2.可读性 清晰好过聪明（Clear is better than clever）</description>
    </item>
    
    <item>
      <title>Go语言中的微服务</title>
      <link>https://TomatoAres.github.io/posts/microservices-in-go/</link>
      <pubDate>Wed, 14 Aug 2019 23:04:12 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/microservices-in-go/</guid>
      <description>Go语言中的微服务 摘要 我最近在墨尔本 Golang 聚会上就如何开发微服务和框架做了一次演讲。在本文中，我将与您分享我的想法（此外，它对我来说是一个很好的复习）。
在这里，我要介绍以下框架：
 Go Micro Go Kit Gizmo Kite  框架简介 Go Micro 这是我认为最受欢迎的框架之一。有很多博客文章和简单的例子可供使用参考。您可以从 microhq 在 Medium 或 @MicroHQ 获得 Go Micro 的最新更新。
那么，什么是 Go Micro ?
它是一个可拔插的 RPC 框架，用于在 Go 中编写微服务。开箱即用，您将看到：
 服务发现 - 自动向服务发现系统注册的应用程序。 负载均衡 - 客户端负载均衡，用于平衡服务实例之间请求的负载。 同步通信 - 提供请求/响应传输层。 异步通信 - 内置发布/订阅功能。 消息编码 - 基于消息的 Content-Type 请求头的编码/解码。 RPC 客户端/服务器打包 - 利用上述特性并公开接口来构建微服务。  Go Micro 架构可以描述为三层堆栈。
顶层包括 Server-Client 模型和服务抽象。该服务器是用于编写服务的基础。而客户端提供了一个接口，用于向服务端发起请求。
底层包含以下类型的插件：
 Broker - 提供一个消息代理接口，用于异步发布/订阅通信。 Codec - 用于编码/解码消息。支持的格式包括 json,bson,protobuf,msgpack 等。 Registry - 提供服务发现机制（默认为 Consul ）。 Selector - 基于注册表构建的负载均衡抽象。 它允许使用诸如 random,roundrobin,leastconn 等算法“选择”服务。 Transport - 服务之间同步请求/响应通信的接口。  Go Micro 还提供 Sidecar 等功能。这允许您使用Go以外的语言编写的服务。 Sidecar 提供服务注册，gRPC 编码/解码和HTTP处理程序。它有多种语言版本。</description>
    </item>
    
    <item>
      <title>Hugo github.io 无样式问题</title>
      <link>https://TomatoAres.github.io/posts/my-first-post/</link>
      <pubDate>Mon, 12 Aug 2019 17:13:32 +0800</pubDate>
      
      <guid>https://TomatoAres.github.io/posts/my-first-post/</guid>
      <description>Hugo github.io 无样式问题 hugo 建站后，生成静态页面并上传github仓库，无法正常显示主题样式
hugo --theme=ananke --baseUrl=&amp;quot;http://TomatoAres.github.io/&amp;quot;  将上述命令中的 http 改为 https 即可解决
hugo --theme=ananke --baseUrl=&amp;quot;https://TomatoAres.github.io/&amp;quot;  参考：使用Hugo搭建个人博客</description>
    </item>
    
  </channel>
</rss>